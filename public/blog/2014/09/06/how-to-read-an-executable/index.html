
<!DOCTYPE html>


<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<title>How is a binary executable organized? Let&#39;s explore it! - Polina Soshnin</title>
<meta name="author" content="Julia Evans">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="description" content="How is a binary executable organized? Let&#39;s explore it!">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="canonical" href="https://jvns.ca/blog/2014/09/06/how-to-read-an-executable/">
<link href="/favicon.ico" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Julia Evans" type="application/atom+xml">
 
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Montserrat:700,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Alegreya:400,900,700' rel='stylesheet' type='text/css'>
</head>
<body>
<div id="wrap">
<header role="banner">
<hgroup>
<h1><a href="/">Polina Soshnin</a></h1>
</hgroup>
<ul class="header-links">
<span><li><a href="/about">About</a></li>
<li><a href="/projects">Projects</a></li></span>
    <li><a href="https://github.com/polinadotio">Github</a></li></span>
    <li><a href="https://www.linkedin.com/in/polinasoshnin">LinkedIn</a></li></span>
</ul>
</header>
<nav role="navigation" class="header-nav"><ul class="main-navigation">
<li><a href="/categories/favorite/">Favorites</a></li>
<li><a href="/zines">Zines</a></li>
</ul>
</nav>
<div id="main">
<div id="content">

<div>
<article class="hentry" role="article">
<header>
<h1 class="entry-title">How is a binary executable organized? Let&#39;s explore it!</h1>

<div class="post-tags">
  
  •
  
    <a class="post-tag" href="/categories/how-things-work">how-things-work</a> 	•
  
  
</div>
<p class="meta">
<time datetime="2014-09-06T11:18:38" pubdate data-updated="true"></time>
</p>
</header>
<div class="entry-content">
     <p>I used to think that executables were totally impenetrable. I&rsquo;d
compile a C program, and then that was it! I had a Magical Binary
Executable that I could no longer read.</p>

<p>It is not so! Executable file formats are regular file formats that
you can understand. I&rsquo;ll explain some simple tools to start! We&rsquo;ll be
working on Linux, with ELF binaries. (binaries are kind of the
definition of platform-specific, so this is all platform-specific.)
We&rsquo;ll be using C, but you could just as easily look at output from any
compiled language.</p>

<p>Let&rsquo;s write a simple C program, <code>hello.c</code>:</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Penguin!\n&quot;);
}
</code></pre>

<p>Then we compile it (<code>gcc -o hello hello.c</code>), and we have a binary called
<code>hello</code>. This originally seems impenetrable (how do we even binary?!),
but let&rsquo;s see how we can investigate it! We&rsquo;re going to learn what
<strong>symbols</strong>, <strong>sections</strong>, and <strong>segments</strong> are. At a high level:</p>

<ul>
<li><strong>symbols</strong> are like function names, and are used to answer &ldquo;If I call
<code>printf</code> and it&rsquo;s defined somewhere else, how do I find it?&rdquo;</li>
<li>symbols are organized into <strong>sections</strong> &ndash; code lives in one section
(<code>.text</code>), and data in another (<code>.data</code>, <code>.rodata</code>)</li>
<li>sections are organized into <strong>segments</strong></li>
</ul>

<p></p>

<p>Throughout we&rsquo;ll use a tool called <code>readelf</code> to look at these.</p>

<p>So, let&rsquo;s dive into our binary!</p>

<h2 id="step-1-open-it-in-a-text-editor">Step 1: open it in a text editor!</h2>

<p>This is most naive possible way to view a binary. If run <code>cat hello</code>,
I get something like this:</p>

<pre>
ELF>@@H@8
@@@@@@��88@@@@�� ((`(`�
PP`P`��P�td@,,Q�tdR�td((`(`��/lib64/ld-linux-x86-64.so.2GNUGNUϨ�n��8�w�j7*oL�h��
__gmon_start__libc.so.6puts__libc_start_mainGLIBC_2.2.5ui
1```H��k����H���5 H�[]�fff.�H�=p
UH��t�H��]�H`��]Ð�UH����@�����]Ð�����������H�l$�L�d$�H�- L�%
L�l$�L�t$�L�|$�H�\$�H��8L)�A��I��H��I���s���H��t1@L��L��D��A��H��H9�u�H�\H�l$L�d$L�l$
L�t$(L�|$0H��8��Ð�������������UH��SH�H�
H���t�(`DH���H�H���u�H�[]Ð�H��o���H��Penguin!;,����H
</pre>

<p>There&rsquo;s text here, though! This was not a total failure. In particular
it says &ldquo;Penguin!&rdquo; and &ldquo;ELF&rdquo;. ELF is the name of the binary format. So
that&rsquo;s something! Then there are a bunch of unprintable symbols, which
isn&rsquo;t a huge surprise because this is a binary.</p>

<h2 id="step-2-use-readelf-to-see-the-symbol-table">Step 2: use <code>readelf</code> to see the symbol table</h2>

<p>Throughout we&rsquo;re going to use a tool called <code>readelf</code> to explore our
binary. Let&rsquo;s start by running <code>readelf --symbols</code> on it. (another
popular tool to do this is <code>nm</code>)</p>

<pre><code>$ readelf --symbols hello 
   Num:    Value          Size Type    Bind   Vis      Ndx Name
    48: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@@GLIBC_2.2.5
    59: 0000000000400410     0 FUNC    GLOBAL DEFAULT   13 _start
    61: 00000000004004f4    16 FUNC    GLOBAL DEFAULT   13 main
</code></pre>

<p>(<a href="https://gist.github.com/jvns/0f82a7655d32bb6b331e">full output here</a>)</p>

<p>Here we see three <em>symbols</em>: <code>main</code> is the address of my <code>main()</code>
function. <code>puts</code> looks like a reference to the <code>printf</code> function I called
in it (which I guess the compiler changed to <code>puts</code> as an
optimization?). <code>_start</code> is pretty important.</p>

<p>When the program starts running, you might think it starts at <code>main</code>.
It doesn&rsquo;t! It <em>actually</em> goes to <code>_start</code>. This does a bunch of Very
Important Things that I don&rsquo;t understand very well, including calling
<code>main</code>. So I won&rsquo;t explain them.</p>

<p>So, what&rsquo;s a symbol?</p>

<h3 id="symbols">Symbols</h3>

<p>When you write a program, you might write a function called <code>hello</code>.
When you compile the program, the binary for that function is labelled
with a <strong>symbol</strong> called <code>hello</code>. If I call a function (like <code>printf</code>)
from a library, we need a way to look up the code for that function!
The process of looking up functions from libraries is called
<strong>linking</strong>. It can happen either just after we compile the program
(&ldquo;static linking&rdquo;) or when we run the program (&ldquo;dynamic linking&rdquo;).</p>

<p>So symbols are what allow linking to work! Let&rsquo;s find the symbol for
printf! It&rsquo;ll be in <code>libc</code>, where all the C standard library
functions are.</p>

<p>If I run <code>nm</code> on my copy of libc, it tells me &ldquo;no symbols&rdquo;. But the
internet tells me I can use <code>objdump -tT</code> instead! This works!
<code>objdump -tT /lib/x86_64-linux-gnu/libc-2.15.so</code> gives me
<a href="https://gist.github.com/jvns/13bae55c3d463cdad809">this output</a>.</p>

<p>If you look at it, you&rsquo;ll see <code>sprintf</code>, <code>strlen</code>, <code>fork</code>, <code>exec</code>, and
everything you might expect libc to have. From here we can start to
imagine how dynamic linking works &ndash; we see that <code>hello</code> calls <code>puts</code>,
and then we can look up the location of <code>puts</code> in libc&rsquo;s symbol table.</p>

<h2 id="step-3-use-objdump-to-see-the-binary-and-learn-about-sections">Step 3: use <code>objdump</code> to see the binary, and learn about sections!</h2>

<p>Opening our binary in a text editor was a bad way to open it.
<code>objdump</code> is a better way. Here&rsquo;s an excerpt:</p>

<pre><code>$ objdump -s hello
Contents of section .text:
 400410 31ed4989 d15e4889 e24883e4 f0505449  1.I..^H..H...PTI
 400420 c7c0a005 400048c7 c1100540 0048c7c7  ....@.H....@.H..
 400430 f4044000 e8c7ffff fff49090 4883ec08  ..@.........H...
Contents of section .interp:
 400238 2f6c6962 36342f6c 642d6c69 6e75782d  /lib64/ld-linux-
 400248 7838362d 36342e73 6f2e3200           x86-64.so.2.    
Contents of section .rodata:
 4005f8 01000200 50656e67 75696e21 00        ....Penguin!.   
</code></pre>

<p>You can see that it shows us all the bytes in the file as hex on the
left, and a translation into ASCII on the right.</p>

<p>The are a whole bunch of <strong>sections</strong> here (see
<a href="https://gist.github.com/jvns/64aa2c85e083e0031609">this gist</a> for the
whole thing). This shows you all the bytes in your binary! Some
sections we care about:</p>

<ul>
<li><code>.text</code> is the program&rsquo;s actual code (the assembly). <code>_start</code> and
<code>main</code> are both part of the <code>.text</code> section.</li>
<li><code>.rodata</code> is where some read-only data is stored (in this case, our
string &ldquo;Penguin!&rdquo;)</li>
<li><code>.interp</code> is the filename of the dynamic linker!</li>
</ul>

<p>The major difference between <em>sections</em> and <em>segments</em> is that
sections are used at link time (by <code>ld</code>) and segments are used at
execution time. <code>objdump</code> shows us the contents of the sections, which
is nice, but doesn&rsquo;t give us as much metadata about the sections as
I&rsquo;d like. Let&rsquo;s try <code>readelf</code> instead:</p>

<pre><code>$ readelf --sections hello
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [13] .text             PROGBITS         0000000000400410  00000410
       00000000000001d8  0000000000000000  AX       0     0     16
  [15] .rodata           PROGBITS         00000000004005f8  000005f8
       000000000000000b  0000000000000000   A       0     0     4
  [24] .data             PROGBITS         0000000000601010  00001010
       0000000000000010  0000000000000000  WA       0     0     8
  [25] .bss              NOBITS           0000000000601020  00001020
       0000000000000010  0000000000000000  WA       0     0     8
  [26] .comment          PROGBITS         0000000000000000  00001020
       000000000000002a  0000000000000001  MS       0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
</code></pre>

<p>(<a href="https://gist.github.com/jvns/37ce4ad26758b403f6b3">full output</a>)</p>

<p>Neat! We can see <code>.text</code> is executable and read-only, <code>.rodata</code> (&ldquo;read
only data&rdquo;) is read-only, and <code>.data</code> is read-write.</p>

<h2 id="step-4-look-at-some-assembly">Step 4: Look at some assembly!</h2>

<p>We mentioned briefly that <code>.text</code> contains assembly code. We can
actually look at what it is really easily. If we were magicians, we
would already be able to read and understand this:</p>

<pre><code>Contents of section .text:
 400410 31ed4989 d15e4889 e24883e4 f0505449  1.I..^H..H...PTI
 400420 c7c0a005 400048c7 c1100540 0048c7c7  ....@.H....@.H..
 400430 f4044000 e8c7ffff fff49090 4883ec08  ..@.........H...
</code></pre>

<p>It starts with <code>31ed4989</code>. Those are bytes that our CPU interprets as
code! And runs! However we are not magicians (I don&rsquo;t know what <code>31
ed</code> means!) and so we will use a disassembler instead.</p>

<pre><code>$ objdump -d ./hello
Disassembly of section .text:

0000000000400410 &lt;_start&gt;:
  400410:       31 ed                   xor    %ebp,%ebp
  400412:       49 89 d1                mov    %rdx,%r9
  400415:       5e                      pop    %rsi
  400416:       48 89 e2                mov    %rsp,%rdx
  400419:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
</code></pre>

<p><a href="https://gist.github.com/jvns/75298b0a5b6cde5de175">full output here</a></p>

<p>So we see that <code>31 ed</code> is xoring two things. Neat! That&rsquo;s all the
assembly we&rsquo;ll do for now.</p>

<h2 id="step-5-segments">Step 5: Segments!</h2>

<p>Finally, a program is organized into <strong>segments</strong> or <strong>program
headers</strong>. Let&rsquo;s look at the segments for our program using <code>readelf
--segments hello</code>.</p>

<pre><code>Program Headers:
  [... removed ...]
  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                 0x000000000000001c 0x000000000000001c  R      1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000006d4 0x00000000000006d4  R E    200000
  LOAD           0x0000000000000e28 0x0000000000600e28 0x0000000000600e28
                 0x00000000000001f8 0x0000000000000208  RW     200000
  [... removed ...]

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym
       .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt
       .text .fini .rodata .eh_frame_hdr .eh_frame
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.ABI-tag .note.gnu.build-id 
   06     .eh_frame_hdr 
   07     
   08     .ctors .dtors .jcr .dynamic .got 

</code></pre>

<p>Segments are used to determine how to separate different parts of the
program into memory. The first <code>LOAD</code> segment is marked R E (read /
execute) and the second is <code>RW</code> (read/write). <code>.text</code> is in the first
segment (we want to read it but never write to it), and <code>.data</code>,
<code>.bss</code> are in the second (we need to write to them, but not execute
them).</p>

<h2 id="not-magic">Not magic!</h2>

<p>Executables aren&rsquo;t magic. ELF is a file format like any other! You can
use <code>readelf</code>, <code>nm</code>, and <code>objdump</code> to inspect your Linux binaries. Try
it out! Have fun.</p>

<p>Other resources:</p>

<ul>
<li>I found
<a href="http://www.bottomupcs.com/elf.html">this introduction to ELF</a>
helpful for explaining sections and segments</li>
<li>There&rsquo;s a wonderful
<a href="https://code.google.com/p/corkami/wiki/ELF101">graphic showing the structure of an ELF binary</a>.</li>
<li>For learning more about how linkers work, there&rsquo;s a wonderful
<a href="http://lwn.net/Articles/276782/">20 part series about linkers</a>,
which I wrote about
<a href="http://jvns.ca/blog/2013/12/10/day-40-learning-about-linkers/">here</a>
and
<a href="http://jvns.ca/blog/2013/12/10/day-40-12-things-i-learned-today-about-linkers/">here</a>.</li>
<li>I haven&rsquo;t talked much about assembly at all here! Read Dan Luu&rsquo;s
<a href="http://danluu.com/edit-binary/">Editing Binaries: Easier than it sounds</a></li>
</ul>

<p><small> Thanks very much to the amazing
<a href="http://akaptur.github.io">Allison Kaptur</a> and
<a href="http://danluu.com">Dan Luu</a> for reading a draft of this.</small></p>
</div>
<footer>
<div class="sharing">
<a href="http://twitter.com/share" class="twitter-share-button" data-url="https://jvns.ca/blog/2014/09/06/how-to-read-an-executable/" data-via="b0rk" data-counturl="https://jvns.ca/blog/2014/09/06/how-to-read-an-executable/">Tweet</a>
</div>
<p class="meta">
   
    <a class="basic-alignment left" href="https://jvns.ca/blog/2014/09/18/you-can-be-a-kernel-hacker/" title="Previous Post: You can be a kernel hacker!">You can be a kernel hacker!</a>
  
   
    <a class="basic-alignment right" href="https://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/" title="Previous Post: What happens if you write a TCP stack in Python?">What happens if you write a TCP stack in Python?</a>
  
</p>
</footer>
</article>
</div>

</div>
</div>
<nav role="navigation" class="footer-nav"> <a href="/">Archives</a>
</nav>
<footer role="contentinfo"><span class="credit">&copy; 2016 Polina Soshnin.
</footer>
</div>
</body>
</html>

