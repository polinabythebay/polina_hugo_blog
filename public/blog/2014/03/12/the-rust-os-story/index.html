
<!DOCTYPE html>


<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<title>Writing an OS in Rust in tiny steps (Steps 1-5) - Polina Soshnin</title>
<meta name="author" content="Julia Evans">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="description" content="Writing an OS in Rust in tiny steps (Steps 1-5)">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="canonical" href="https://jvns.ca/blog/2014/03/12/the-rust-os-story/">
<link href="/favicon.ico" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Julia Evans" type="application/atom+xml">
 
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Montserrat:700,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Alegreya:400,900,700' rel='stylesheet' type='text/css'>
</head>
<body>
<div id="wrap">
<header role="banner">
<hgroup>
<h1><a href="/">Polina Soshnin</a></h1>
</hgroup>
<ul class="header-links">
<span><li><a href="/about">About</a></li>
<li><a href="/projects">Projects</a></li></span>
    <li><a href="https://github.com/polinadotio">Github</a></li></span>
    <li><a href="https://www.linkedin.com/in/polinasoshnin">LinkedIn</a></li></span>
</ul>
</header>
<nav role="navigation" class="header-nav"><ul class="main-navigation">
<li><a href="/categories/favorite/">Favorites</a></li>
<li><a href="/zines">Zines</a></li>
</ul>
</nav>
<div id="main">
<div id="content">

<div>
<article class="hentry" role="article">
<header>
<h1 class="entry-title">Writing an OS in Rust in tiny steps (Steps 1-5)</h1>

<div class="post-tags">
  
  •
  
    <a class="post-tag" href="/categories/kernel">kernel</a> 	•
  
    <a class="post-tag" href="/categories/favorite">favorite</a> 	•
  
    <a class="post-tag" href="/categories/rust">rust</a> 	•
  
  
</div>
<p class="meta">
<time datetime="2014-03-12T07:09:10" pubdate data-updated="true"></time>
</p>
</header>
<div class="entry-content">
     <p>I&rsquo;m giving a talk tomorrow on writing a kernel in Rust.</p>

<p>My experience of writing a kernel that it was like jumping in puddles:
it&rsquo;s a lot of fun, and there are a lot of mishaps:</p>

<p><img src="/images/puddle.gif"></p>

<p>Here are a few of the tiny steps I took. There are more, but those
will have to wait for the evening.</p>

<p></p>

<h3 id="step-1-copy-some-code-from-the-internet">Step 1: copy some code from the internet</h3>

<p>I didn&rsquo;t know what I was doing, so I didn&rsquo;t want to start from
scratch! So I started with something that already existed! Behold
<a href="https://github.com/charliesome/rustboot">rustboot</a>, a tiny 32-bit
kernel written in Rust.</p>

<p>Rustboot does only two things, but it does them well!</p>

<ol>
<li>Turn the screen red</li>
<li>Hang</li>
</ol>

<p>Of course what it actually does is a bit more complicated &ndash; there&rsquo;s</p>

<ul>
<li>a loader written in assembly</li>
<li>a Makefile that lets you run it with <code>qemu</code></li>
<li>Some Rust code to clear the screen</li>
</ul>

<p>Here&rsquo;s the code that clears the screen:</p>

<pre><code>unsafe fn clear_screen(background: Color) {
    range(0, 80*25, |i| {
        *((0xb8000 + i * 2) as *mut u16) = (background as u16) &lt;&lt; 12;
    });
}
</code></pre>

<p>What does this mean? The key part here is that the address of the VGA
buffer is <code>0xb8000</code>, so we&rsquo;re setting some bytes there. And there&rsquo;s a
loop.</p>

<h3 id="step-2-turn-the-screen-blue-instead">Step 2: Turn the screen blue instead.</h3>

<p>The first thing I did was:</p>

<ol>
<li>Make sure I could run <code>rustboot</code>.</li>
<li>Change &lsquo;red&rsquo; to &lsquo;blue&rsquo; and run it again</li>
</ol>

<p>This sounds silly, but psychologically it&rsquo;s an important step! It
forced me to look at the code and understand how it worked, and it was
really exciting that it worked right away.</p>

<h3 id="step-3-start-writing-i-o-functions">Step 3: Start writing I/O functions</h3>

<p>The next obvious step now that I had a blue screen was to try to write
a <code>print</code> function.</p>

<p>Here&rsquo;s what it looked like!</p>

<pre><code>pub fn putchar(x: u16, y: u16, c: u8) {
    let idx : uint =  (y * VGA_WIDTH * 2 + x * 2) as uint;
    unsafe {
        *((VGA_ADDRESS + idx) as *mut u16) = make_vgaentry(c, fg_color, bg_color);
    }
}
</code></pre>

<p>I didn&rsquo;t explain the <code>unsafe</code> block before. Everything inside
<code>unsafe{}</code> is <em>unsafe</em> code. This particular code is unsafe because it
accesses a memory address directly. Wrapping it in an unsafe block
tells Rust &ldquo;okay, I checked and I promise this code is actually doing
the right thing and won&rsquo;t blow anything up&rdquo;.</p>

<p>We can also look at <code>make_vgaentry</code>:</p>

<pre><code>fn make_vgaentry(c: u8, fg: Color, bg: Color) -&gt; u16 {
    let color = fg as u16 | (bg as u16 &lt;&lt; 4);
    return c as u16 | (color &lt;&lt; 8);
}
</code></pre>

<p>In the VGA buffer, each character is represented by 2 bytes (so a
<code>u16</code>). The lower 8 bits are the ASCII character, and the upper 8 bits
are the foreground and background colour (4 bits each). <code>Color</code> here
is an enum so that I can refer to Red or Green directly.</p>

<p>I found this part pretty approachable and it didn&rsquo;t take too long.
Which isn&rsquo;t to say that I didn&rsquo;t have problems! I had SO MANY
PROBLEMS. Most of my problems were to do with arrays and string and
iterating over strings. Here&rsquo;s some code that caused me much pain:</p>

<pre><code>pub fn write(s: &amp;str) {
    let bytes : &amp;[u8] = as_bytes(s);
    for b in super::core::slice::iter(bytes) {
        putc(*b);
    }
}
</code></pre>

<p>This code looks simple! It is a lie.
Friends. Here were some questions that I needed to ask to write this code.</p>

<ul>
<li>How do I turn a string into a byte array? (<code>as_bytes()</code>)</li>
<li>What is the type of a byte array? (<code>&amp;[u8]</code>)</li>
<li>How do I iterate over a byte array? (+ &ldquo;it still doesn&rsquo;t work!&rdquo;, 4 times)</li>
</ul>

<p>Also, what is this <code>super::core::slice::iter</code> business? This brings us
to a fairly long digression, and an important point</p>

<h3 id="why-you-can-t-write-a-kernel-in-python">Why you can&rsquo;t write a kernel in Python</h3>

<p>So you want to write an operating system, let&rsquo;s say for x86. You need
to write this in a programming language!</p>

<p>Can you write your operating system in Python (using CPython, say)?
You cannot. This is not being curmudgeonly! It is actually just not
possible.</p>

<p>What happens when you write <code>print &quot;Hello!&quot;</code> in Python?</p>

<p>Well, many things happen. But the <em>last</em> thing that happens is that
the CPython interpreter will do something like <code>printf(&quot;Hello&quot;)</code>. And
you might think, well, maybe I could link against the code for
<code>printf</code> somehow!</p>

<p>But what <code>printf</code> does is it calls the <code>write()</code> system call. The
<code>write()</code> system call is implemented IN YOUR KERNEL.</p>

<p>OH WAIT YOU DON&rsquo;T HAVE A KERNEL YET. YOU ARE WRITING ONE.</p>

<p>This also means that you can&rsquo;t write a kernel as a &ldquo;normal&rdquo; C program
which includes C libraries. Any C libraries. All C libraries for Linux
are built on top of some version of <code>libc</code>, which makes calls to the
Linux kernel! So if you&rsquo;re <em>writing</em> a kernel, this doesn&rsquo;t work.</p>

<h3 id="why-you-can-write-a-kernel-in-rust">Why you <em>can</em> write a kernel in Rust</h3>

<p>Writing Rust code has many of the same problems, of course! By
default, if you compile a Rust program with a print statement, it will
call your kernel&rsquo;s equivalent to <code>write</code>.</p>

<p>But! Unlike with Python, you can put <code>#[no_std]</code> at the beginning of
your Rust program.</p>

<p>You lose a lot! You can no longer</p>

<ul>
<li>allocate memory</li>
<li>do threading</li>
<li>print anything</li>
<li>many many more things</li>
</ul>

<p>It&rsquo;s still totally fine to define functions and make calculations,
though. And you can of course define your own functions to allocate
memory.</p>

<p>You also lose things like Rust&rsquo;s iterators, which is sad!</p>

<h3 id="rust-core">rust-core</h3>

<p><a href="https://github.com/thestinger/rust-core">rust-core</a> is &ldquo;a standard
library for Rust with freestanding support&rdquo;. What this means is that
if you&rsquo;re writing an OS, <code>rust-core</code> will provide you with all kinds
of helpful data structures and functions that you lost when you wrote
<code>#[no_std]</code>.</p>

<p>I found using this library pretty confusing, but the author hangs out
in IRC all the time and was really friendly to me, so it wasn&rsquo;t a huge
problem.</p>

<p>So back to <code>super::core::slice::iter</code>! This says &ldquo;iterate over this
using an iteration function from <code>rust-core</code>&ldquo;</p>

<h3 id="step-4-keyboard-interrupts">Step 4: keyboard interrupts!</h3>

<p>So it took me a few days to learn how to print because I needed
to learn about freestanding mode and get confused about rust-core and
at the same time I didn&rsquo;t really understand Rust&rsquo;s types very well.</p>

<p>Once that was done, I wanted to be able to do the following:</p>

<ol>
<li>Press a key (&lsquo;j&rsquo; for example)</li>
<li>Have that letter appear on the screen.</li>
</ol>

<p>I thought this wouldn&rsquo;t be too hard. I was pretty wrong.</p>

<p>I wrote about what went wrong in
<a href="http://jvns.ca/blog/2013/12/04/day-37-how-a-keyboard-works/">After 5 days, my OS doesn&rsquo;t crash when I press a key</a>.</p>

<p>It lists all my traumas in excruciating detail and I won&rsquo;t repeat them
here. Go read it. It&rsquo;s kinda worth it. I&rsquo;ll wait.</p>

<h3 id="step-5-malloc">Step 5: malloc!</h3>

<p>After I&rsquo;d done that, I thought it might be fun to be able to allocate
memory.</p>

<p>You may be surprised at this point. We have printed strings! We have
made our keyboard work! Didn&rsquo;t we need to allocate memory? Isn&rsquo;t
that&hellip; <em>important</em>?</p>

<p>It turns out that you can get away without doing it pretty easily!
Rust would automatically create variables on the stack for me, so I
could use local variables. And for anything else I could use global
variables, and the space for those was laid out at compile time.</p>

<p>But allocating memory seemed like a fun exercise. To allocate
something on the heap in Rust, you can do</p>

<p><code>let a = ~2</code></p>

<p>This creates a pointer to a <code>2</code> on the heap. Of course, we talked
before about how there is no malloc! So I wrote one, and then made
sure that Rust knew about it.</p>

<p>You can see the <code>malloc</code> function I wrote in
<a href="http://jvns.ca/blog/2013/12/10/day-39-i-wrote-a-malloc/">Writing malloc wrong, for fun</a></p>

<p>The hardest parts of this were not writing the function, but</p>

<ul>
<li>getting the type right</li>
<li>Understanding how Rust&rsquo;s language features can be turned on and off.</li>
</ul>

<p>WHAT DO YOU MEAN TURNED ON AND OFF, you may ask!</p>

<p>So in <code>rust-core</code>, if you go to
<a href="https://github.com/thestinger/rust-core/blob/85c28bb64ec093aff9e3f81110200793c6291467/core/heap.rs#L32">heap.rs</a>,
you&rsquo;ll see this code:</p>

<pre><code>#[lang = &quot;exchange_malloc&quot;]
pub unsafe fn alloc(size: uint) -&gt; *mut u8 {
    if size == 0 {
        0 as *mut u8
    } else {
        let ptr = malloc(size);
        if ptr == 0 as *mut u8 {
            out_of_memory()
        }
        ptr
    }
}
</code></pre>

<p>This weird-looking <code>#[lang = &quot;exchange_malloc&quot;]</code> bit means &ldquo;Code like
<code>let x = ~2</code> is now allowed to work&rdquo;. It requires there to be an
implementation of <code>malloc</code>, which I wrote. It also needs implements of
<code>realloc</code> and <code>free</code>, but I left those blank :)</p>

<p>Before seeing that, Rust would not compile code that allocated memory.</p>

<p>I think this language feature gating is really cool: it means that you
can write Rust programs that can allocate memory, but not do
threading. Or that can do hardly anything at all!</p>

<p>I need to get up now.</p>

<p><strong>Next up:</strong> running problems! AND SOMETHING IS ERASING MY PROGRAM WHILE
IT IS RUNNING.</p>
</div>
<footer>
<div class="sharing">
<a href="http://twitter.com/share" class="twitter-share-button" data-url="https://jvns.ca/blog/2014/03/12/the-rust-os-story/" data-via="b0rk" data-counturl="https://jvns.ca/blog/2014/03/12/the-rust-os-story/">Tweet</a>
</div>
<p class="meta">
   
    <a class="basic-alignment left" href="https://jvns.ca/blog/2014/03/21/my-rust-os-will-never-be-finished/" title="Previous Post: My Rust OS will never be finished (and it&#39;s a success!)">My Rust OS will never be finished (and it&#39;s a success!)</a>
  
   
    <a class="basic-alignment right" href="https://jvns.ca/blog/2014/03/10/debugging-shared-library-problems-with-strace/" title="Previous Post: Debugging shared library problems with strace">Debugging shared library problems with strace</a>
  
</p>
</footer>
</article>
</div>

</div>
</div>
<nav role="navigation" class="footer-nav"> <a href="/">Archives</a>
</nav>
<footer role="contentinfo"><span class="credit">&copy; 2016 Polina Soshnin.
</footer>
</div>
</body>
</html>

