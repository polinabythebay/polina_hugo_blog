
<!DOCTYPE html>


<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<title>What happens when you start a process on Linux? - Polina Soshnin</title>
<meta name="author" content="Julia Evans">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="description" content="What happens when you start a process on Linux?">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="canonical" href="https://jvns.ca/blog/2016/10/04/exec-will-eat-your-brain/">
<link href="/favicon.ico" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Julia Evans" type="application/atom+xml">
 
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Montserrat:700,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Alegreya:400,900,700' rel='stylesheet' type='text/css'>
</head>
<body>
<div id="wrap">
<header role="banner">
<hgroup>
<h1><a href="/">Polina Soshnin</a></h1>
</hgroup>
<ul class="header-links">
<span><li><a href="/about">About</a></li>
<li><a href="/projects">Projects</a></li></span>
    <li><a href="https://github.com/polinadotio">Github</a></li></span>
    <li><a href="https://www.linkedin.com/in/polinasoshnin">LinkedIn</a></li></span>
</ul>
</header>
<nav role="navigation" class="header-nav"><ul class="main-navigation">
<li><a href="/categories/favorite/">Favorites</a></li>
<li><a href="/zines">Zines</a></li>
</ul>
</nav>
<div id="main">
<div id="content">

<div>
<article class="hentry" role="article">
<header>
<h1 class="entry-title">What happens when you start a process on Linux?</h1>

<div class="post-tags">
  
  •
  
    <a class="post-tag" href="/categories/favorite">favorite</a> 	•
  
  
</div>
<p class="meta">
<time datetime="2016-10-04T20:07:01" pubdate data-updated="true"></time>
</p>
</header>
<div class="entry-content">
     

<p>This is about how fork and exec works on Unix. You might already know about this, but some
people don&rsquo;t, and I was surprised when I learned it a few years back!</p>

<p>So. You want to start a process. We&rsquo;ve talked a lot about <strong>system calls</strong> on this blog &ndash; every time you start a process, or open a file, that&rsquo;s a system call. So you might think that there&rsquo;s a system call like this</p>

<pre><code>start_process([&quot;ls&quot;, &quot;-l&quot;, &quot;my_cool_directory&quot;])
</code></pre>

<p>This is a reasonable thing to think and apparently it&rsquo;s how it works in DOS/Windows. I was
going to say that this <em>isn&rsquo;t</em> how it works on Linux. But! I went and looked at the docs and apparently there is a <a href="http://man7.org/linux/man-pages/man3/posix_spawn.3.html">posix_spawn</a> system call that does basically this. Shows what I know. Anyway, we&rsquo;re not going to talk about that.</p>

<h3 id="fork-and-exec">fork and exec</h3>

<p><code>posix_spawn</code> on Linux is behind the scenes implemented in terms of 2 system calls called
<code>fork</code> and <code>exec</code> (actually <code>execve</code>), which are what people usually actually use anyway. On OS X apparently people use <code>posix_spawn</code> and fork/exec are discouraged! But we&rsquo;ll talk about Linux.</p>

<p>Every process in Linux lives in a &ldquo;process tree&rdquo;. You can see that tree by running
<code>pstree</code>. The root of the tree is <code>init</code>, with PID 1. Every process (except init) has a parent, and any process has many children.</p>

<p>So, let&rsquo;s say I want to start a process called <code>ls</code> to list a directory. Do I just have a
baby <code>ls</code>? No!</p>

<p>Instead of having children, what I do is you have a child that is a clone of myself, and then that child gets its brain eaten and turns into <code>ls</code>. Really.</p>

<p>We start out like this:</p>

<pre><code>my parent
    |- me
</code></pre>

<p>Then I run <code>fork()</code>. I have a child which is a clone of myself.</p>

<pre><code>my parent
    |- me
       |-- clone of me
</code></pre>

<p>Then I organize it so that my child runs <code>exec(&quot;ls&quot;)</code>. That leaves us with</p>

<pre><code>my parent
    |- me
       |-- ls
</code></pre>

<p>and once ls exits, I&rsquo;ll be all by myself again. Almost</p>

<pre><code>my parent
    |- me
       |-- ls (zombie)
</code></pre>

<p>At this point ls is actually a zombie process! That means it&rsquo;s dead, but it&rsquo;s waiting around for me in case I want to check on its return value (using the <code>wait</code> system call.) Once I get its return value, I will really be all alone again.</p>

<pre><code>my parent
    |- me
</code></pre>

<h3 id="what-fork-and-exec-looks-like-in-code">what fork and exec looks like in code</h3>

<p>This is one of the exercises you have to do if you&rsquo;re going to write a shell (which is a
very fun and instructive project! Kamal has a great workshop on Github about how to do it:
<a href="https://github.com/kamalmarhubi/shell-workshop">https://github.com/kamalmarhubi/shell-workshop</a>)</p>

<p>It turns out that with a bit of work &amp; some C or Python skills you can write a very
simple shell (like bash!) in C or Python in just a few hours (at least if you have someone sitting next to you who knows what they&rsquo;re doing, longer if not :)). I&rsquo;ve done this and it was awesome.</p>

<p>Anyway, here&rsquo;s what fork and exec look like in a program. I&rsquo;ve written fake C pseudocode. Remember that <a href="https://rachelbythebay.com/w/2014/08/19/fork/">fork can fail!</a></p>

<pre><code>int pid = fork();
// now i am split in two! augh!
// who am I? I could be either the child or the parent
if (pid == 0) {
    // ok I am the child process
    // ls will eat my brain and I'll be a totally different process 
    exec([&quot;ls&quot;])
} else if (pid == -1) {
    // omg fork failed this is a disaster 
} else {
    // ok i am the parent
    // continue my business being a cool program
    // I could wait for the child to finish if I want
}

</code></pre>

<h3 id="ok-what-does-it-mean-for-your-brain-to-be-eaten-julia">ok what does it mean for your brain to be eaten julia</h3>

<p>Processes have a lot of attributes!</p>

<p>You have</p>

<ul>
<li>open files (including open network connections)</li>
<li>environment variables</li>
<li>signal handlers (what happens when you run Ctrl+C on the program?)</li>
<li>a bunch of memory (your &ldquo;address space&rdquo;)</li>
<li>registers</li>
<li>an &ldquo;executable&rdquo; that you ran (/proc/$pid/exe)</li>
<li>cgroups and namespaces (&ldquo;linux container stuff&rdquo;)</li>
<li>a current working directory</li>
<li>the user your program is running as</li>
<li>some other stuff that I&rsquo;m forgetting</li>
</ul>

<p>When you run <code>execve</code> and have another program eat your brain, actually almost everything
stays the same! You have the same environment variables and signal handlers and open files and more.</p>

<p>The only thing that changes is, well, all of your memory and registers and the program that you&rsquo;re running. Which is a pretty big deal.</p>

<h3 id="why-is-fork-not-super-expensive-or-copy-on-write">why is fork not super expensive (or: copy on write)</h3>

<p>You might ask &ldquo;julia, what if I have a process that&rsquo;s using 2GB of memory! Does that mean every time I start a subprocess all that 2GB of memory gets copied?! That sounds expensive!&rdquo;</p>

<p>It turns out that Linux implements &ldquo;copy on write&rdquo; for fork() calls, so that for all the
2GB of memory in the new process it&rsquo;s just like &ldquo;look at the old process! it&rsquo;s the same!&rdquo;.
And then if the either process writes any memory, then at that point it&rsquo;ll start copying.
But if the memory is the same in both processes, there&rsquo;s no need to copy!</p>

<h3 id="why-you-might-care-about-all-this">why you might care about all this</h3>

<p>Okay, julia, this is cool trivia, but why does it matter? Do the details about which
signal handlers or environment variables get inherited or whatever actually make a
difference in my day-to-day programming?</p>

<p>Well, maybe! For example, there&rsquo;s this <a href="http://kamalmarhubi.com/blog/2015/06/30/my-favourite-bug-so-far-at-the-recurse-center/">delightful bug on Kamal&rsquo;s blog</a>. It talks about how Python sets the signal handler for SIGPIPE to ignore. So if you run a program from inside Python, by default it will ignore SIGPIPE! This means that the program will <strong>behave differently</strong> depending on whether you started it from a Python script or from your shell! And in this case it was causing a weird bug!</p>

<p>So, your program&rsquo;s environment (environment, signal handlers, etc.) can matter! It
inherits its environment from its parent process, whatever that was! This can sometimes be
a useful thing to know when debugging.</p>

</div>
<footer>
<div class="sharing">
<a href="http://twitter.com/share" class="twitter-share-button" data-url="https://jvns.ca/blog/2016/10/04/exec-will-eat-your-brain/" data-via="b0rk" data-counturl="https://jvns.ca/blog/2016/10/04/exec-will-eat-your-brain/">Tweet</a>
</div>
<p class="meta">
   
    <a class="basic-alignment left" href="https://jvns.ca/blog/2016/10/09/switching-to-hugo/" title="Previous Post: Switching to Hugo">Switching to Hugo</a>
  
   
    <a class="basic-alignment right" href="https://jvns.ca/blog/2016/10/02/a-list-of-container-software/" title="Previous Post: A list of Linux container software">A list of Linux container software</a>
  
</p>
</footer>
</article>
</div>

</div>
</div>
<nav role="navigation" class="footer-nav"> <a href="/">Archives</a>
</nav>
<footer role="contentinfo"><span class="credit">&copy; 2016 Polina Soshnin.
</footer>
</div>
</body>
</html>

