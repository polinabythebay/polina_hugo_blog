
<!DOCTYPE html>


<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<title>How CPU load averages work (and using them to triage webserver performance!) - Polina Soshnin</title>
<meta name="author" content="Julia Evans">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="description" content="How CPU load averages work (and using them to triage webserver performance!)">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="canonical" href="https://jvns.ca/blog/2016/02/07/cpu-load-averages/">
<link href="/favicon.ico" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Julia Evans" type="application/atom+xml">
 
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Montserrat:700,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Alegreya:400,900,700' rel='stylesheet' type='text/css'>
</head>
<body>
<div id="wrap">
<header role="banner">
<hgroup>
<h1><a href="/">Polina Soshnin</a></h1>
</hgroup>
<ul class="header-links">
<span><li><a href="/about">About</a></li>
<li><a href="/projects">Projects</a></li></span>
    <li><a href="https://github.com/polinadotio">Github</a></li></span>
    <li><a href="https://www.linkedin.com/in/polinasoshnin">LinkedIn</a></li></span>
</ul>
</header>
<nav role="navigation" class="header-nav"><ul class="main-navigation">
<li><a href="/categories/favorite/">Favorites</a></li>
<li><a href="/zines">Zines</a></li>
</ul>
</nav>
<div id="main">
<div id="content">

<div>
<article class="hentry" role="article">
<header>
<h1 class="entry-title">How CPU load averages work (and using them to triage webserver performance!)</h1>

<div class="post-tags">
  
  •
  
    <a class="post-tag" href="/categories/performance">performance</a> 	•
  
  
</div>
<p class="meta">
<time datetime="2016-02-07T17:48:47" pubdate data-updated="true"></time>
</p>
</header>
<div class="entry-content">
     

<p>CPU load averages have long been a little mysterious to me. I understood that
low is good, and high is bad, but I thought of them as a mostly inscrutable
number. I have now reached a small epiphany about them, which I would like to
share with you!</p>

<p>I tweeted earlier today:</p>

<blockquote>
<p>I understand CPU load averages now! If I have a load average of 6, and am processing 60 requests/second, then each one takes <sup>6</sup>&frasl;<sub>60</sub>=0.1s of CPU time</p>
</blockquote>

<p>and someone <a href="https://twitter.com/EitanAdler/status/696386442080030720">responded</a>:</p>

<blockquote>
<p>CPU load average is the number of processes in the runnable state. Little to nothing to do with CPU time.</p>
</blockquote>

<p>I thought this was a totally reasonable response. I also still thought I was
<em>right</em>, but I needed to do some work first, and it wouldn&rsquo;t fit in a tweet.</p>

<p>It turns out that I was kinda wrong, but I think also kinda right! What follows will hopefully be correct. When doing calculations, I’m going to assume that your processes using CPU are all doing it for the same reason, and that reason is to serve HTTP requests.</p>

<p>Before I explain what load averages have to do with CPU time (spoiler: we&rsquo;re
going to do a tiny bit of queueing theory!), I want to tell you what a load
average is, and why the formula I tweeted is awesome.</p>

<h3 id="what-s-a-load-average">What’s a load average?</h3>

<p>Modern operating systems (since, like, <a href="http://www.cim.mcgill.ca/~franco/OpSys-304-427/lecture-notes/node46.html">4.2BSD in 1983</a>) can run more than one process on a single CPU (this is called “CPU scheduling”). My computer is running 300 processes right now! The operating system keeps track of a state for every process. The man page for <code>ps</code> lists them:</p>

<pre><code>PROCESS STATE CODES
       Here are the different values that the s, stat and state output specifiers (header &quot;STAT&quot; or &quot;S&quot;) will display to describe the state
       of a process:
       D    uninterruptible sleep (usually IO)
       R    running or runnable (on run queue)
       S    interruptible sleep (waiting for an event to complete)
       T    stopped, either by a job control signal or because it is being traced.
       W    paging (not valid since the 2.6.xx kernel)
       X    dead (should never be seen)
       Z    defunct (&quot;zombie&quot;) process, terminated but not reaped by its parent.
</code></pre>

<p>The load average is the average, in the last minute / 5 minutes / 15 minutes, of the number of processes in a running or runnable state. As far as I understand, &lsquo;runnable&rsquo; means &ldquo;I&rsquo;d be running if you&rsquo;d let me&rdquo;. Processes that are asleep don’t count. Almost every process on my computer is asleep at any given time.</p>

<p>Given this definition, you may understand why someone would say this has “Little to nothing to do with CPU time”. It doesn&rsquo;t seem like it would!</p>

<h3 id="a-quick-note-on-multiple-cpu-cores">A quick note on multiple CPU cores</h3>

<p>If there are 3 processes that want to run on a CPU at the same time, and your computer has 4 CPU cores, then you’re totally okay! They can all run. So a load average of 3 is fine is you have 4 cores, and bad if you have 1 core.</p>

<p>The number of cores you have doesn’t affect the formula we’re going to talk about here, though.</p>

<h3 id="why-cpu-load-averages-are-awesome">Why CPU load averages are awesome</h3>

<p>The other day at work, I had a server that had a load average of 6. It was processing 60 HTTP requests per second. (the numbers here are all fake)</p>

<p>Both of these numbers are easy to get! The load average is in the output of <code>top</code> (for instance <code>load average: 6.12, 6.01, 5.98</code>), and I got the requests per second processed (or throughput) by counting log lines in the service&rsquo;s log file.</p>

<p>So! According to our formula from above, each request was taking 6 / 60 = 0.1s = 100ms of time using-or-waiting-for-the-CPU. I asked my awesome coworker to double check this division to make sure that was right. 100ms is a bajillion years of CPU time, and I was super concerned. That story is for another time! But being able to calculate that number so quickly was SUPER USEFUL to me for understanding the server&rsquo;s performance.</p>

<h3 id="why-the-formula-is-correct">Why the formula is correct</h3>

<p>So! I posited this formula that tells you CPU time per request = load average / request throughput (requests per second). Why does that work?</p>

<p>There&rsquo;s this theorem called <a href="https://en.wikipedia.org/wiki/Little%27s_law">Little&rsquo;s Law</a>, that states:</p>

<blockquote>
<p>The long-term average number of customers in a stable system L is equal to the long-term average effective arrival rate, λ, multiplied by the average time a customer spends in the system, W; or expressed algebraically: L = λW.</p>
</blockquote>

<p>This is pretty intuitive: if 10 people per hour (W) arrive at your store, and they spend 30 minutes each there (λ), then on average there will be 5 people (L) at a time in your store.</p>

<p>Now, let&rsquo;s imagine the CPU is your store, and that HTTP requests are people. The load average tells you how many processes at a time are in line to use the CPU (L). Since in my case I have 1 HTTP request / process, this is the same as the number of requests in line to use the CPU. Note that we care about the steady-state load average &ndash; if the load is constantly changing then it&rsquo;s much harder to reason about. So we want the &ldquo;average load average&rdquo;. In my example system at work, the load average had been about 6 for a long time.</p>

<p>If your system is in a steady state (constant load), then the rate of incoming requests will on average, over a long period of time, be the same as the rate of finishing requests. That rate is W.</p>

<p>Lastly, λ is the amount of time each request spends on the CPU (in a running or runnable state).</p>

<p>So:</p>

<ul>
<li>L = load average (average # requests in a running or runnable state)</li>
<li>λ = average total time each request spends in a running or runnable state</li>
<li>W = throughput (requests per second)</li>
</ul>

<p>So if we want to do my example from the previous section, we get:</p>

<p>time spent on CPU = λ = L / W = 6 / 60 = 0.1s per request.</p>

<h3 id="caveats">Caveats</h3>

<p>There are quite a few assumptions built into this formula, which I&rsquo;ll make explicit now. First, I told you &ldquo;The load average tells you how many processes at a time are in line to use the CPU (L)&rdquo;. This isn&rsquo;t actually true!</p>

<p>The <a href="https://en.wikipedia.org/wiki/Load_(computing)">Wikipedia page on load averages remarks that</a>:</p>

<blockquote>
<p>However, Linux also includes processes in uninterruptible sleep states (usually waiting for disk activity), which can lead to markedly different results if many processes remain blocked in I/O due to a busy or stalled I/O system.</p>
</blockquote>

<p>So, here are the cases when this &ldquo;CPU time per request = load average / throughput&rdquo; formula won&rsquo;t work for you:</p>

<ul>
<li>some of your processes are in uninterruptible sleep</li>
<li>your system has a highly fluctuating load average / throughput</li>
<li>you&rsquo;re handling more than 1 HTTP request per thread (for instance if you&rsquo;re using Node or Go or&hellip;).</li>
<li>the CPU activity on your system is caused by something other than your HTTP request processing</li>
<li>this time (time running + time waiting for the CPU) includes time spent doing context switches between processes, and time spent on-CPU inside the kernel</li>
</ul>

<p>It&rsquo;s also worth noting that the load average is an exponentially decaying average. This means that if your load average is changing over time, it&rsquo;s hard to know what the non-exponentially-decaying load average is.</p>

<p>There’s likely another caveat I’ve missed, but I think that’s most of them.</p>

<h3 id="a-version-for-time-spent-on-the-cpu">a version for time spent <em>on</em> the CPU</h3>

<p>We&rsquo;ve found a formula for &ldquo;time the request spends on the CPU (or waiting for it to be free)&rdquo;. But what if we wanted to ignore the time it spent waiting? I have an idea that I made up just now.</p>

<p>If the CPU load is low (like, less than half your number of cores), I think it&rsquo;s reasonable to assume that any process that wants to be scheduled gets scheduled immediately. So there&rsquo;s nothing to do.</p>

<p>But what if your CPU is overloaded? Suppose I have 4 CPUs. Then we could instead define</p>

<ul>
<li>L = average number of processes in a running state (which should be 4, since the CPU is at capacity)</li>
<li>λ = average time each request spends in a running state</li>
<li>W = throughput (requests per second)</li>
</ul>

<p>Then we can still try to calculate our new λ, from our example from before!</p>

<p>λ = L / W = 4 / 60 = 0.066 s = 66ms per request on the CPU.</p>

<p>I think this math still holds up, but it feels a little shakier to me. I would love comments on this.</p>

<h3 id="this-formula-awesome">this formula = awesome</h3>

<p>I had a good experience with this formula yesterday! Being able to quickly triage the number of milliseconds of CPU time per request was an awesome start to doing some more in-depth performance analysis! (which I won’t go into here)</p>

<p>I hope it will help you as well! If you think I&rsquo;ve gotten this all wrong, <a href="https://twitter.com/b0rk">let me know on twitter</a> :)</p>

<p><small> Thanks to Kamal Marhubi, Darius Bacon, Dan Luu, and Sean Allen for comments </small></p>

</div>
<footer>
<div class="sharing">
<a href="http://twitter.com/share" class="twitter-share-button" data-url="https://jvns.ca/blog/2016/02/07/cpu-load-averages/" data-via="b0rk" data-counturl="https://jvns.ca/blog/2016/02/07/cpu-load-averages/">Tweet</a>
</div>
<p class="meta">
   
    <a class="basic-alignment left" href="https://jvns.ca/blog/2016/02/09/til-clock-skew-exists/" title="Previous Post: TIL: clock skew exists">TIL: clock skew exists</a>
  
   
    <a class="basic-alignment right" href="https://jvns.ca/blog/2016/01/23/fast-integer-sets-with-roaring-bitmaps/" title="Previous Post: Fast integer sets with Roaring Bitmaps (and, making friends with your modern CPU)">Fast integer sets with Roaring Bitmaps (and, making friends with your modern CPU)</a>
  
</p>
</footer>
</article>
</div>

</div>
</div>
<nav role="navigation" class="footer-nav"> <a href="/">Archives</a>
</nav>
<footer role="contentinfo"><span class="credit">&copy; 2016 Polina Soshnin.
</footer>
</div>
</body>
</html>

