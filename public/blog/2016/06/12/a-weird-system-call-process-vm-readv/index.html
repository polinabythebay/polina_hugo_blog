
<!DOCTYPE html>


<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<title>How to spy on a Ruby program - Polina Soshnin</title>
<meta name="author" content="Julia Evans">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="description" content="How to spy on a Ruby program">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="canonical" href="https://jvns.ca/blog/2016/06/12/a-weird-system-call-process-vm-readv/">
<link href="/favicon.ico" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Julia Evans" type="application/atom+xml">
 
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Montserrat:700,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Alegreya:400,900,700' rel='stylesheet' type='text/css'>
</head>
<body>
<div id="wrap">
<header role="banner">
<hgroup>
<h1><a href="/">Polina Soshnin</a></h1>
</hgroup>
<ul class="header-links">
<span><li><a href="/about">About</a></li>
<li><a href="/projects">Projects</a></li></span>
    <li><a href="https://github.com/polinadotio">Github</a></li></span>
    <li><a href="https://www.linkedin.com/in/polinasoshnin">LinkedIn</a></li></span>
</ul>
</header>
<nav role="navigation" class="header-nav"><ul class="main-navigation">
<li><a href="/categories/favorite/">Favorites</a></li>
<li><a href="/zines">Zines</a></li>
</ul>
</nav>
<div id="main">
<div id="content">

<div>
<article class="hentry" role="article">
<header>
<h1 class="entry-title">How to spy on a Ruby program</h1>

<div class="post-tags">
  
  •
  
    <a class="post-tag" href="/categories/favorite">favorite</a> 	•
  
  
</div>
<p class="meta">
<time datetime="2016-06-12T10:43:06" pubdate data-updated="true"></time>
</p>
</header>
<div class="entry-content">
     

<p>I love debugging tools. One of the most frustrating things to me is &ndash; when I run a Ruby or Python program, I can&rsquo;t find out what that program is doing RIGHT NOW.</p>

<p>You might eagerly interrupt me &ndash; julia, you say, you can use pdb! or pry! or <a href="https://github.com/tmm1/rbtrace">rbtrace!</a>.</p>

<p>So, let me explain. If I&rsquo;m running a program on the JVM with PID 4242, I can run  <code>jstack -p 4242</code>, and it will print the current stack trace of the Java program. Any Java program. It doesn&rsquo;t need any special configuration!!</p>

<p>In C, you can run <code>sudo perf top</code> on a Linux machine and it&rsquo;ll instantly give you a live profile of all the C functions that are running. For any C program. (did you know you can do this?! this is one of my favorite things. it is amazing!). <code>pstack</code> does something similar to <code>jstack</code>, but only for 32-bit binaries :(.</p>

<p>In Ruby.. there&rsquo;s nothing, yet. You can pre-instrument your Ruby program and there are libraries you can use, but this stuff isn&rsquo;t built into the ecosystem in the same way. This makes me grumpy because I&rsquo;m like IF JAVA CAN HAVE NICE THINGS THEN WHY NOT RUBY AND PYTHON??</p>

<p>So, let&rsquo;s talk about how you could build jstack for Ruby.</p>

<h3 id="step-1-gdb">step 1: gdb</h3>

<p>Scott Francis from Shopify has this <a href="https://gist.github.com/csfrancis/11376304">great gdb script</a> that will print a Ruby stacktrace if you attach to it with gdb. You can read how the script works in <a href="http://engineering.shopify.com/112738884-adventures-in-production-rails-debugging">Adventures in Production Rails Debugging</a>.</p>

<p>It took me a couple of days to understand what&rsquo;s going on with that script &ndash; when you attach to a program with gdb, it seems like basically black magic, but as usual it&rsquo;s actually not magic at all.</p>

<p>First, let&rsquo;s explore a little with gdb. This is a little messy, but I want you to see how you explore a program&rsquo;s memory with gdb because I think it&rsquo;s cool. I&rsquo;ve redacted some of the longer output.</p>

<pre><code># HELLO RUBY. What is the address of the current thread in this process?
(gdb) p ruby_current_thread
$1 = (rb_thread_t *) 0x55b89eb775b0

# SWEET. let's get the current frame pointer! That is where
# we are going to find the stack trace!
(gdb) p ruby_current_thread-&gt;cfp
$2 = (rb_control_frame_t *) 0x7f217f1dbfc0

# Oh, but I didn't just want the address! Let's see what's inside!
(gdb) p *(ruby_current_thread-&gt;cfp)
$3 = {pc = 0x55b89ecd2ca0, sp = 0x7f217f0dc020, iseq = 0x55b89ecd2840,
    flag = 833, self = 94251425195000, klass = 8, ep = 0x55b89ecd2df8,    block_iseq = 0x0,
    proc = 0, me = 0x0}

# Next step: we need to look at the `iseq` property. That's another
# pointer, and we'll also dereference it to see what's inside
(gdb) p ruby_current_thread-&gt;cfp-&gt;iseq
$4 = (rb_iseq_t *) 0x55b89ecd2840
(gdb) p *(ruby_current_thread-&gt;cfp-&gt;iseq)
$5 = {type = ISEQ_TYPE_TOP, location = {path = 94251425516800, absolute_path =
8, base_label = 94251425523360, label = 94251425523360,      first_lineno = 1},
iseq = 0x55b89ecd2c80, iseq_encoded = 0x55b89ecd2ca0, iseq_size = 2, mark_ary =
[... left out a bunch of stuff here ...]}

# Phew. That was kind of long. Luckily, we just care about
# `location.path` and `location.label.`
# Let's print those out!
(gdb) p *((struct RString*) (ruby_current_thread-&gt;cfp + 1)-&gt;iseq.location.label)
$7 = {basic = {...}, as = {heap = ..., 
    ary = &quot;block in initialize\000\000\000\000&quot;}}
(gdb) p *((struct RString*) (ruby_current_thread-&gt;cfp + 1)-&gt;iseq.location.path)
$8 = {basic = {flags = 546318437, klass = 94660819015280}, as = {heap = {len = 64, 
ptr = 0x5617f3432440 &quot;/home/bork/.rbenv/versions/2.1.6/lib/ruby/2.1.0/webrick/utils.rb&quot;,}
</code></pre>

<p><strong>This is amazing</strong>. It&rsquo;s amazing, because we started with practically nothing &ndash; just an address of the current thread! And we finished with a file (<code>/home/bork/.rbenv/versions/2.1.6/lib/ruby/2.1.0/webrick/utils.rb</code>), and a place we are in that file: <code>block in initialize</code>. We had to write a kind of weird thing to get that information (<code>*((struct RString*) (ruby_current_thread-&gt;cfp + 1)-&gt;iseq.location.label)</code>), but we got it.</p>

<p>The <a href="https://gist.github.com/csfrancis/11376304">script</a> from before basically does what I just did, except it&rsquo;s a little smarter and can also get you line numbers. Cool.</p>

<h3 id="gdb-isn-t-good-enough">gdb isn&rsquo;t good enough</h3>

<p>So this is pretty awesome. We can attach to almost any Ruby process and get a stack trace! Isn&rsquo;t that what I wanted?</p>

<p>Well, not quite. gdb uses the <code>ptrace</code> system call, in this case to stop the program in its tracks and then intensely query it for its internals. This is slower than what I want. Maybe my Ruby program needed to actually keep running!</p>

<p>When I ran that gdb command <code>p *((struct RString*) (ruby_current_thread-&gt;cfp + 1)-&gt;iseq.location.path)</code> &ndash; it does a ton of stuff. I was going to paste the strace output of what gdb is actually doing, but it is 20 megabytes of system calls. So here&rsquo;s a small excerpt: Every time I need to read memory from the target program (which is what looking up strings is doing!), it issues a bunch of system calls like</p>

<pre><code>ptrace(PTRACE_PEEKTEXT, 5677, 0x5617f3432440, [0x6f622f656d6f682f]) = 0
ptrace(PTRACE_PEEKTEXT, 5677, 0x5617f3432448, [0x6e6562722e2f6b72]) = 0
ptrace(PTRACE_PEEKTEXT, 5677, 0x5617f3432450, [0x6f69737265762f76]) = 0
ptrace(PTRACE_PEEKTEXT, 5677, 0x5617f3432458, [0x362e312e322f736e]) = 0
ptrace(PTRACE_PEEKTEXT, 5677, 0x5617f3432460, [0x6275722f62696c2f]) = 0
ptrace(PTRACE_PEEKTEXT, 5677, 0x5617f3432468, [0x2f302e312e322f79]) = 0
ptrace(PTRACE_PEEKTEXT, 5677, 0x5617f3432470, [0x2f6b636972626577]) = 0
ptrace(PTRACE_PEEKTEXT, 5677, 0x5617f3432478, [0x62722e736c697475]) = 0
ptrace(PTRACE_PEEKTEXT, 5677, 0x5617f3432480, [0x780062722e736c00]) = 0
</code></pre>

<p>So, how does gdb work? Here&rsquo;s what it does:</p>

<p>First, it reads debugging info out of my Ruby binary. This tells it the size and structure of the structs it needs access to &ndash; <code>rb_iseq_t</code>, <code>struct RString</code>, <code>rb_control_frame_t</code>. If you don&rsquo;t know what the memory at address means, you can&rsquo;t do anything!</p>

<p>So, let&rsquo;s say I run <code>p ruby_current_thread-&gt;cfp</code> in gdb. What does gdb do, exactly?</p>

<ol>
<li>Look up the address of <code>ruby_current_thread</code> in the symbol table. Let&rsquo;s say that&rsquo;s 0x5617f3432440.</li>
<li>Look in the debug info to figure out what type it has (<code>rb_thread_t</code>)</li>
<li>Go get the bytes at address <code>0x5617f3432440</code>, by using the <code>ptrace(PTRACE_PEEKTEXT</code> system call</li>
<li>Look in the debug info to figure out what the offset is of the <code>cfp</code> member of the <code>rb_thread_t</code> struct.</li>
</ol>

<p>we&rsquo;re done! So, this is really cool. We&rsquo;ve learned how gdb works! <a href="https://twitter.com/nasrat">Pris Nasrat</a> helped me figure out how gdb works.</p>

<h3 id="dwarf">DWARF</h3>

<p>Before we move on, we need to talk about DWARF. Remember when I said it reads debugging info out of the Ruby binary? That uses a format called DWARF. I&rsquo;m not going to go into how you read that info right now because frankly I don&rsquo;t know.</p>

<p>But &ndash; when people say &ldquo;you need to compile this with debugging symbols&rdquo;, what they mean by &ldquo;debugging symbols&rdquo; is DWARF.</p>

<h3 id="spying-on-our-program-without-gdb">spying on our program without gdb.</h3>

<p>Okay, cool! So, what if we wanted to get stack traces out of a program <strong>without</strong> gdb? Is that a thing that could happen? Turns out: yes!</p>

<p>When we were learning how gdb works, we figured out that as long as you have</p>

<ol>
<li>the debugging info, and</li>
<li>the ability to read memory from your target program</li>
</ol>

<p>you&rsquo;re good to go! gdb happens to use the <code>ptrace</code> system call to read memory from the Ruby program, but that&rsquo;s not necessary, it turns out! We are going to make a new friend.</p>

<h3 id="process-vm-readv"><code>process_vm_readv</code></h3>

<p><a href="http://www.cipht.net">Julian Squires</a> was the person who made me think about all of this in the first place, and I emailed him like UGH JULIAN HOW DO I MAKE THIS WORK and he was like &ldquo;<code>process_vm_readv</code>!&ldquo;. So, what&rsquo;s that? It&rsquo;s a Linux system call! The man page says:</p>

<pre><code>These  system calls transfer data between the address space of the
calling process (&quot;the local process&quot;) and the process identified by pid
(&quot;the remote process&quot;).  The data moves directly between the address
spaces of the two processes,  without  passing  through kernel space.
</code></pre>

<p>So, if I want to spy on the memory of a Ruby program, for example because I&rsquo;m writing a debugger, I can use <code>process_vm_readv</code>! Neat!</p>

<p>The reason this is awesome and better than what gdb does is &ndash; as far as I can tell, the impact of <code>process_vm_readv</code> on the running process is WAY SMALLER. You just spy on the memory and get out of the way!</p>

<h3 id="actually-building-a-thing">actually building a thing</h3>

<p>So far this is all just talk. Does this actually work, Julia? Is it real? Sort of! I wrote a program in Rust to sample stack traces. Rust was a cool way to do this because I don&rsquo;t know how to manually manage memory in C or C++, so literally my C program to do this was just instant memory leaks. In Rust I just had to deal with the compiler, and then I ended up with a working program pretty quickly!</p>

<p>So, I wrote a prototype program to do this. You can see the source <a href="https://github.com/jvns/ruby-stacktrace/blob/master/src/main.rs">here</a>.</p>

<h3 id="it-works-kind-of">it works, kind of</h3>

<p>And it WORKED. It started spitting out stack traces of the Ruby program I was writing, every 10 milliseconds! It was pretty fast! It was amazing! I used it to generate a <a href="https://github.com/BrendanGregg/FlameGraph.pl">flame graph</a>. here is my cool flame graph:</p>

<p><a href="/images/sampling.png"><img src="/images/sampling.png"></a></p>

<p>So, that was the good news. The bad news is that I didn&rsquo;t actually learn to use the DWARF libraries yet, so I hardcoded all the struct types, and as a result it doesn&rsquo;t work on anybody&rsquo;s computer but my own. And then I have an actual programming job to do, which so far is in the way of progress. But instead of feeling bad that I haven&rsquo;t actually gotten the software to work yet on other peoples&rsquo; computers, I thought I would take a couple of hours and tell you how it works! Maybe this will motivate me to actually fix it up and make it into Real Software some day later!</p>

<h3 id="debuggers-are-exciting">debuggers are exciting</h3>

<p>this made me even more excited about writing debugging tools! Some questions I have</p>

<ul>
<li>does this tool, that can spit out Ruby stack traces quickly for any Ruby program with debugging symbols enabled, actually exist somewhere and I just don&rsquo;t know about it?</li>
<li>what about for Python?</li>
<li>maybe it doesn&rsquo;t exist because a Linux-only Ruby debugging tool is sort of a weird thing?</li>
<li>if we <em>can</em> build this, and it doesn&rsquo;t exist yet, what other amazing debugging technology could we build?</li>
</ul>

<p>Thanks to Julian Squires, Pris Nasrat, and Kamal Marhubi for helping me with new system calls / gdb / writing Rust!</p>

</div>
<footer>
<div class="sharing">
<a href="http://twitter.com/share" class="twitter-share-button" data-url="https://jvns.ca/blog/2016/06/12/a-weird-system-call-process-vm-readv/" data-via="b0rk" data-counturl="https://jvns.ca/blog/2016/06/12/a-weird-system-call-process-vm-readv/">Tweet</a>
</div>
<p class="meta">
   
    <a class="basic-alignment left" href="https://jvns.ca/blog/2016/06/13/should-you-be-scared-of-signals/" title="Previous Post: Should you be scared of Unix signals?">Should you be scared of Unix signals?</a>
  
   
    <a class="basic-alignment right" href="https://jvns.ca/blog/2016/06/07/strace-y/" title="Previous Post: A useful new strace feature">A useful new strace feature</a>
  
</p>
</footer>
</article>
</div>

</div>
</div>
<nav role="navigation" class="footer-nav"> <a href="/">Archives</a>
</nav>
<footer role="contentinfo"><span class="credit">&copy; 2016 Polina Soshnin.
</footer>
</div>
</body>
</html>

