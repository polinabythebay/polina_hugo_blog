
<!DOCTYPE html>


<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<title>PAPERS ARE AMAZING: Profiling threaded programs with Coz - Polina Soshnin</title>
<meta name="author" content="Julia Evans">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="description" content="PAPERS ARE AMAZING: Profiling threaded programs with Coz">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="canonical" href="https://jvns.ca/blog/2015/10/31/papers-are-amazing-profiling-threaded-programs-with-coz/">
<link href="/favicon.ico" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Julia Evans" type="application/atom+xml">
 
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Montserrat:700,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Alegreya:400,900,700' rel='stylesheet' type='text/css'>
</head>
<body>
<div id="wrap">
<header role="banner">
<hgroup>
<h1><a href="/">Polina Soshnin</a></h1>
</hgroup>
<ul class="header-links">
<span><li><a href="/about">About</a></li>
<li><a href="/projects">Projects</a></li></span>
    <li><a href="https://github.com/polinadotio">Github</a></li></span>
    <li><a href="https://www.linkedin.com/in/polinasoshnin">LinkedIn</a></li></span>
</ul>
</header>
<nav role="navigation" class="header-nav"><ul class="main-navigation">
<li><a href="/categories/favorite/">Favorites</a></li>
<li><a href="/zines">Zines</a></li>
</ul>
</nav>
<div id="main">
<div id="content">

<div>
<article class="hentry" role="article">
<header>
<h1 class="entry-title">PAPERS ARE AMAZING: Profiling threaded programs with Coz</h1>

<div class="post-tags">
  
  •
  
    <a class="post-tag" href="/categories/performance">performance</a> 	•
  
  
</div>
<p class="meta">
<time datetime="2015-10-31T10:40:02" pubdate data-updated="true"></time>
</p>
</header>
<div class="entry-content">
     

<p>HI BLOG FRIENDS!</p>

<p>I usually don&rsquo;t read papers. I only read <a href="http://research.google.com/pubs/pub43146.html">one paper</a> so far this year (which I love). I only read it because my friend Maggie printed it out and gave it to me.</p>

<p>SO. Yesterday I got handed 3 (three!) printed out papers from the amazing organizers of <a href="http://www.meetup.com/Papers-We-Love-Montreal/">Papers We Love Montreal</a>. And I woke up this morning and started reading one (because, Saturday morning). And then I had to tell you all about it because this paper is so cool. Okay, enough backstory.</p>

<p>The paper we&rsquo;re going to talk about is <a href="https://web.cs.umass.edu/publication/docs/2015/UM-CS-2015-008.pdf">COZ: Finding Code that Counts with Causal Profiling</a> (pdf). I found it super easy to read. Here is what I got out of it so far!</p>

<h2 id="profiling-threaded-applications-is-hard">Profiling threaded applications is hard</h2>

<p>Profiling single-threaded applications where everything happens synchronously is pretty straightforward. If one part of the program is slow, it&rsquo;ll show up as taking 10% of the time or something, and then you can target that part of the program for optimization.</p>

<p>But, when you start to use threads, everything gets way more complicated. The paper uses this program as an example:</p>

<pre><code>void a() { // ˜6.7 seconds
  for(volatile size_t x=0; x&lt;2000000000; x++) {}
}
void b() { // ˜6.4 seconds
  for(volatile size_t y=0; y&lt;1900000000; y++) {}
}
int main() {
  // Spawn both threads and wait for them.
  thread a_thread(a), b_thread(b);
  a_thread.join(); b_thread.join();
}
</code></pre>

<p>Speeding up one of <code>a()</code> or <code>b()</code> won&rsquo;t help you, because they <em>both</em> need to finish in order for the program to finish. (this is totally different from if we ran <code>a(); b()</code>, in which case speeding up <code>a()</code> could give you an up to 50% increase in speed).</p>

<p>Okay, so profiling threaded programs is hard. What next?</p>

<h2 id="speed-up-one-thread-to-see-if-that-thread-is-the-problem">Speed up one thread to see if that thread is the problem</h2>

<p>The core idea in this paper is &ndash; if you have a line of code in a thread, and you want to know if it&rsquo;s making your program slow, speed up that line of code to see if it makes the <strong>whole program</strong> faster!</p>

<p>Of course, you can&rsquo;t actually speed up a thread. But you <em>can</em> slow down all other threads! So that&rsquo;s what they do. The implemention here is super super super interesting &ndash; they use the <code>perf</code> Linux system to do this, and in particular they can do it <strong>without modifying the program&rsquo;s code</strong>. So this is a) wizardry, and b) uses <code>perf</code></p>

<p>Which are both things we love here (<a href="http://jvns.ca/blog/2014/05/13/profiling-with-perf/">omg perf</a>). I&rsquo;m going to refer you to the paper for now to learn more about how they use perf to slow down threads, because I honestly don&rsquo;t totally understand it myself yet. There are some difficult details like &ldquo;if the thread is already waiting on another thread, should we slow it down even more?&rdquo; that they get into.</p>

<h2 id="omg-it-works">omg it works</h2>

<p>The thing that really impressed me about this paper is that they showed the results of running this profiler on real programs (SQLite! Memcached!), and then they could use the profiler results to detect</p>

<ul>
<li>a problem with too many hash table collisions</li>
<li>unnecessary / inefficient uses of locking (&ldquo;this is atomic anyway! no need to lock!&rdquo;)</li>
<li>where it would be more efficient to move code from one thread to another</li>
</ul>

<p>and speed up the program on the workload they were testing by, like, 10%!</p>

<p>They also find out places where speeding up a line of code would introduce a <em>slowdown</em> (because of increased contention around some resource). This paradoxically also helps them make code faster, because that&rsquo;s a good site for figuring out why there&rsquo;s a problem with contention and changing the ways the locks are set up.</p>

<p>Also, they claim that the overhead of this profiling is like 20%? How can this be. This seems like literally magic except that THEY EXPLAIN HOW IT WORKS. Papers. Wow.</p>

<h2 id="actually-running-the-code">Actually running the code</h2>

<p>You can actually download the code <a href="https://github.com/plasma-umass/coz">on GitHub</a>. I tried to compile it and it did not work the first time. I suspect this is because <code>perf</code> changes a little between different Linux versions (I get a bunch of errors about <code>perf.h</code>). It seems like this is something <a href="https://github.com/plasma-umass/coz/issues/16">they&rsquo;re working on</a>. Maybe a future project will be to try to get it to compile and run it on a REAL PROGRAM and see if I can reproduce some of the things they talk about in the paper! We&rsquo;ll see.</p>

<h2 id="async-programming">Async programming?!</h2>

<p>Now I&rsquo;m really curious about if we could do something similar for profiling single-threaded but asynchronous applications (for all the javascript programmers in the world!). Like, if you identified a function call you were interested in speeding up, you could slow down everything else running in the event loop and see if it slowed down the overall program. Maybe someone has already tried this! If so I want to know about it. (I&rsquo;m <a href="https://twitter.com/b0rk">@b0rk</a> on twitter).</p>

<p>Okay, papers are cool. If you know me and want to print a paper you love and give it to me I&rsquo;d be into it.</p>

</div>
<footer>
<div class="sharing">
<a href="http://twitter.com/share" class="twitter-share-button" data-url="https://jvns.ca/blog/2015/10/31/papers-are-amazing-profiling-threaded-programs-with-coz/" data-via="b0rk" data-counturl="https://jvns.ca/blog/2015/10/31/papers-are-amazing-profiling-threaded-programs-with-coz/">Tweet</a>
</div>
<p class="meta">
   
    <a class="basic-alignment left" href="https://jvns.ca/blog/2015/11/09/docker-is-amazing/" title="Previous Post: Docker is amazing">Docker is amazing</a>
  
   
    <a class="basic-alignment right" href="https://jvns.ca/blog/2015/09/10/a-millisecond-isnt-fast-and-how-we-fixed-it/" title="Previous Post: A millisecond isn&#39;t fast (and how we made it 100x faster)">A millisecond isn&#39;t fast (and how we made it 100x faster)</a>
  
</p>
</footer>
</article>
</div>

</div>
</div>
<nav role="navigation" class="footer-nav"> <a href="/">Archives</a>
</nav>
<footer role="contentinfo"><span class="credit">&copy; 2016 Polina Soshnin.
</footer>
</div>
</body>
</html>

