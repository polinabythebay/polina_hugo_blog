
<!DOCTYPE html>


<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<title>How to call Rust from assembly, and vice versa - Polina Soshnin</title>
<meta name="author" content="Julia Evans">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="description" content="How to call Rust from assembly, and vice versa">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="canonical" href="https://jvns.ca/blog/2013/12/01/how-to-call-rust-from-assembly/">
<link href="/favicon.ico" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Julia Evans" type="application/atom+xml">
 
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Montserrat:700,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Alegreya:400,900,700' rel='stylesheet' type='text/css'>
</head>
<body>
<div id="wrap">
<header role="banner">
<hgroup>
<h1><a href="/">Polina Soshnin</a></h1>
</hgroup>
<ul class="header-links">
<span><li><a href="/about">About</a></li>
<li><a href="/projects">Projects</a></li></span>
    <li><a href="https://github.com/polinadotio">Github</a></li></span>
    <li><a href="https://www.linkedin.com/in/polinasoshnin">LinkedIn</a></li></span>
</ul>
</header>
<nav role="navigation" class="header-nav"><ul class="main-navigation">
<li><a href="/categories/favorite/">Favorites</a></li>
<li><a href="/zines">Zines</a></li>
</ul>
</nav>
<div id="main">
<div id="content">

<div>
<article class="hentry" role="article">
<header>
<h1 class="entry-title">How to call Rust from assembly, and vice versa</h1>

<div class="post-tags">
  
  •
  
    <a class="post-tag" href="/categories/kernel">kernel</a> 	•
  
    <a class="post-tag" href="/categories/hackerschool">hackerschool</a> 	•
  
    <a class="post-tag" href="/categories/rust">rust</a> 	•
  
  
</div>
<p class="meta">
<time datetime="2013-12-01T00:00:00" pubdate data-updated="true"></time>
</p>
</header>
<div class="entry-content">
     

<p>In the last few days I&rsquo;ve been working on a kernel in Rust. This has
entailed learning about linkers and foreign function interfaces and
all kinds of things.</p>

<p>To learn this stuff, I read
<a href="http://www.lurklurk.org/linkers/linkers.html">this guide to linkers</a>, looked
at the
<a href="http://static.rust-lang.org/doc/master/tutorial-ffi.html">Rust foreign function interface tutorial</a>,
and asked a million questions on the Rust IRC channel.</p>

<p>Disclaimer: even more than usual, some of this is probably wrong.</p>

<p>So. Linkers.</p>

<p>I have assembly functions that I need to call from Rust, and Rust
functions I need to call from assembly. Everything gets compiled to
assembly eventually, so this is a reasonable thing to do. As far as I
understand it, a function call is just jumping to an address in memory
and putting some stuff on the stack and in registers, and the code
doesn&rsquo;t care at all if that address in memory comes from Rust or C or
assembly or what.</p>

<p>Some terminology:</p>

<ul>
<li>A <strong>calling convention</strong> is about how exactly the stuff gets put on
the stack and in the registers. Rust and C have different calling
conventions.</li>
<li>An <strong>object file</strong> is what you get when you compile some source code
to a library (using <code>gcc</code> or <code>nasm</code> or <code>rustc</code>). It ends in <code>.o</code></li>
<li>A <strong>symbol</strong> is an identifier in a program, like a variable or
function name. Object files have a <strong>symbol table</strong> and can refer to
symbols in other object files.</li>
<li>A <strong>linker</strong> (like <code>ld</code>) combines several object files into one
binary, matching up their symbol tables.</li>
</ul>

<h3 id="calling-rust-from-assembly">Calling Rust from assembly</h3>

<p>So here&rsquo;s an assembly function that calls a Rust function:</p>

<pre><code>global  _interrupt_handler_kbd_wrapper
extern _interrupt_handler_kbd

_interrupt_handler_kbd_wrapper: 
    pushad
    call    _interrupt_handler_kbd
    popad
    iret
</code></pre>

<p><code>extern</code> says that <code>_interrupt_handler_kbd</code> isn&rsquo;t actually defined in
this file, but that <code>nasm</code> shouldn&rsquo;t worry about it when assembling &ndash;
it&rsquo;ll be fixed later. This is like a function declaration in C, except
without the types.</p>

<p>I haven&rsquo;t tested this yet so there&rsquo;s probably something wrong with it.
But it compiles.</p>

<h3 id="calling-assembly-from-rust">Calling assembly from Rust</h3>

<p>External functions are defined in Rust again using the <code>extern</code>
keyword (sound familiar? =D).</p>

<p>I need to get the address of the <code>_interrupt_handler_kbd_wrapper</code> and
<code>idt_load</code> functions in Rust, so I defined them like this:</p>

<pre><code>extern {
    fn _interrupt_handler_kbd_wrapper ();
    fn idt_load(x: *IDTPointer);
}
</code></pre>

<p>You&rsquo;ll notice that I needed to specify the types of the function&rsquo;s
arguments. These don&rsquo;t have return values, but if they did I&rsquo;d need to
write those types too.</p>

<p>The type of <code>_interrupt_handler_kbd_wrapper</code> is <code>extern &quot;C&quot; unsafe
fn()</code>. That&rsquo;s pretty complicated, but let&rsquo;s break it down:</p>

<ul>
<li><code>extern</code> means it&rsquo;s defined in another object file.</li>
<li><code>&quot;C&quot;</code> is the <em>calling convention</em> which we mentioned before.</li>
<li>We have no idea what the function could be doing, so it&rsquo;s <code>unsafe</code>.</li>
</ul>

<p>Then I can just call my <code>extern</code> functions like normal Rust functions.</p>

<h3 id="putting-it-together-the-linker">Putting it together: the linker</h3>

<p>I have a file named <code>linker.ld</code> that contains:</p>

<pre><code>ENTRY(start)
OUTPUT_FORMAT(binary)

SECTIONS {
    . = 0x7e00;

    .text : {
        *(.text)
    }
}
</code></pre>

<p>Then I run</p>

<p><code>i386-elf-ld -T linker.ld runtime.o main.o isr_wrapper.o -o main.bin</code></p>

<p>where <code>main.o</code> is my Rust file and <code>isr_wrapper.o</code> is my assembly
file. You&rsquo;ll notice that now they have a <code>.o</code> extension &ndash; now they&rsquo;re
&ldquo;object files&rdquo; and they&rsquo;re all assembly code.</p>

<p>This <code>ld</code> command puts <code>main.o</code>, <code>runtime.o</code>, and <code>isr_wrapper.o</code>
together into one binary. Basically this matches up symbols with the
same name and makes it work. If an <code>extern</code> function I declare in a
file doesn&rsquo;t exist, then I&rsquo;ll get a linker error like this:</p>

<pre><code>main.o: In function `main':
main.rc:(.text+0x1db): undefined reference to `_interrupt_handler_kbd_wrapper'
</code></pre>

<p>But this kind of linker error isn&rsquo;t scary any more! It just means that
<code>_interrupt_handler_kbd_wrapper</code> isn&rsquo;t in the symbol table of any of
the other object files we&rsquo;re linking.</p>

<h3 id="how-to-look-at-an-object-file-s-symbol-table">How to look at an object file&rsquo;s symbol table</h3>

<p>To see the symbols that are defined in <code>isr_wrapper.o</code>, I can use
<code>objdump</code> like this:</p>

<pre><code>bork@kiwi ~/w/h/rustboot&gt; objdump -t isr_wrapper.o

isr_wrapper.o:     file format elf32-i386

SYMBOL TABLE:
00000000 l    df *ABS*  00000000 isr_wrapper.asm
00000000 l    d  .text  00000000 .text
00000000         *UND*  00000000 _interrupt_handler_kbd
00000000 g       .text  00000000 _interrupt_handler_kbd_wrapper
00000008 g       .text  00000000 idt_load
</code></pre>

<p>You can see here that I&rsquo;ve defined <code>_interrupt_handler_kbd_wrapper</code>
and <code>idt_load</code>, but that <code>_interrupt_handler_kbd</code> is undefined and
needs to be defined in another file.</p>

<p>You can also use <code>objdump -T</code> to look at a dynamically linked <code>.so</code>
file&rsquo;s symbol table. We&rsquo;re not talking about dynamic linking today =).
For example <code>objdump -T  /usr/lib32/libm.so</code> shows me the math
library&rsquo;s symbol table. COOL.</p>

<p>That&rsquo;s all!</p>

<p><small>
You may notice that it doesn&rsquo;t really make sense to call
<code>_interrupt_handler_kbd_wrapper</code> from Rust. I&rsquo;m not actually calling
it, I just need to refer to it so I can store its address.
</small></p>

</div>
<footer>
<div class="sharing">
<a href="http://twitter.com/share" class="twitter-share-button" data-url="https://jvns.ca/blog/2013/12/01/how-to-call-rust-from-assembly/" data-via="b0rk" data-counturl="https://jvns.ca/blog/2013/12/01/how-to-call-rust-from-assembly/">Tweet</a>
</div>
<p class="meta">
   
    <a class="basic-alignment left" href="https://jvns.ca/blog/2013/12/02/types-in-rust/" title="Previous Post: Day 35: Types in Rust, for beginners">Day 35: Types in Rust, for beginners</a>
  
   
    <a class="basic-alignment right" href="https://jvns.ca/blog/2013/11/30/videos-from-pydata-nyc-are-up/" title="Previous Post: Videos from PyData NYC are up!">Videos from PyData NYC are up!</a>
  
</p>
</footer>
</article>
</div>

</div>
</div>
<nav role="navigation" class="footer-nav"> <a href="/">Archives</a>
</nav>
<footer role="contentinfo"><span class="credit">&copy; 2016 Polina Soshnin.
</footer>
</div>
</body>
</html>

