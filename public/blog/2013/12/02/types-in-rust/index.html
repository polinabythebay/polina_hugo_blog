
<!DOCTYPE html>


<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<title>Day 35: Types in Rust, for beginners - Polina Soshnin</title>
<meta name="author" content="Julia Evans">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="description" content="Day 35: Types in Rust, for beginners">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="canonical" href="https://jvns.ca/blog/2013/12/02/types-in-rust/">
<link href="/favicon.ico" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Julia Evans" type="application/atom+xml">
 
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Montserrat:700,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Alegreya:400,900,700' rel='stylesheet' type='text/css'>
</head>
<body>
<div id="wrap">
<header role="banner">
<hgroup>
<h1><a href="/">Polina Soshnin</a></h1>
</hgroup>
<ul class="header-links">
<span><li><a href="/about">About</a></li>
<li><a href="/projects">Projects</a></li></span>
    <li><a href="https://github.com/polinadotio">Github</a></li></span>
    <li><a href="https://www.linkedin.com/in/polinasoshnin">LinkedIn</a></li></span>
</ul>
</header>
<nav role="navigation" class="header-nav"><ul class="main-navigation">
<li><a href="/categories/favorite/">Favorites</a></li>
<li><a href="/zines">Zines</a></li>
</ul>
</nav>
<div id="main">
<div id="content">

<div>
<article class="hentry" role="article">
<header>
<h1 class="entry-title">Day 35: Types in Rust, for beginners</h1>

<div class="post-tags">
  
  •
  
    <a class="post-tag" href="/categories/kernel">kernel</a> 	•
  
    <a class="post-tag" href="/categories/hackerschool">hackerschool</a> 	•
  
    <a class="post-tag" href="/categories/rust">rust</a> 	•
  
  
</div>
<p class="meta">
<time datetime="2013-12-02T00:00:00" pubdate data-updated="true"></time>
</p>
</header>
<div class="entry-content">
     

<p>I found understanding Rust types really confusing, so I wrote up a
small tutorial for myself in an attempt to understand some of them.
This is by no means exhaustive. There is a
<a href="http://static.rust-lang.org/doc/master/rust.html#type-system">types section</a>
in the manual, but it has nowhere near enough examples.</p>

<p>This assumes that you&rsquo;ve read the sections about
<a href="http://static.rust-lang.org/doc/master/tutorial.html#ownership">owned</a>
and
<a href="http://static.rust-lang.org/doc/master/tutorial.html#borrowed-pointers">borrowed</a>
pointers in the Rust tutorial, but not much else.</p>

<p>I&rsquo;m not talking about managed pointers (<code>@</code>) at all. A lot of the
difficulty with Rust types is that the language is constantly
changing, so this will likely be out of date soon.</p>

<p>First, a few preliminaries: it&rsquo;s easier to play with types if you have
a REPL and can interactively check the types of objects. This isn&rsquo;t
really possible in Rust, but there are workarounds.</p>

<h2 id="to-start-out-some-help">To start out: some help</h2>

<h3 id="how-to-get-a-rust-repl">How to get a Rust REPL</h3>

<p>There is no working Rust REPL. However, you can use
<a href="http://sprunge.us/ahKj">this script</a> to approximate one &ndash; it
compiles what you put into it and prints the result. You can&rsquo;t use the
results of what you did previously, though. Save as <code>rustci</code>.</p>

<h3 id="how-to-find-the-type-of-a-variable">How to find the type of a variable</h3>

<p><strong>Edit:</strong> The fantastic <a href="https://github.com/thestinger">Daniel Micay</a>
showed me this function to find the type of a variable. It&rsquo;s included
in the <code>rustci</code> script above, so you can just do</p>

<p><code>let x = 2; type_of(&amp;x)</code></p>

<p>to print the type of <code>2</code>. Amazing. Note that you have to call
<code>type_of</code> with <code>&amp;x</code> and not <code>x</code>.</p>

<p>The function is:</p>

<pre><code>fn type_of&lt;T&gt;(_: &amp;T) -&gt; &amp;'static str {
    unsafe {
        (*std::unstable::intrinsics::get_tydesc::&lt;T&gt;()).name
    }
}
</code></pre>

<p><strong>Hackier approach:</strong></p>

<p>You can also generate a compiler error with the type of a variable <code>y</code>
like this:</p>

<pre><code>fn y() {}
let x: () = y;
</code></pre>

<p>It&rsquo;s a hack, but it will give you an error like this:</p>

<pre><code>error: mismatched types: expected `()` but found `fn()` (expected () but found extern fn)
</code></pre>

<p>which tells us that the type of <code>f</code> is <code>fn()</code>.</p>

<h2 id="the-types">The types!</h2>

<h3 id="primitive-types">Primitive types</h3>

<p>This is an incomplete list.</p>

<p>Integers (signed and unsigned): <code>int</code>, <code>uint</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code></p>

<p>Floats: <code>f32</code>, <code>f64</code></p>

<p>Booleans: <code>bool</code></p>

<p><strong>Primitive type examples</strong></p>

<pre><code>let x: uint = 2;
let y: u8 = 40;
let z: f32 = abc;
</code></pre>

<h3 id="vectors">Vectors</h3>

<p>There are 3 possible types for a vector of <code>u8</code>: <code>[u8, ..N]</code>, <code>&amp;[u8]</code>, <code>~[u8]</code></p>

<p><code>[u8]</code> by itself is not a type.</p>

<p><code>[u8, ..5]</code> is a fixed-size vector of <code>u8</code> of length 5.</p>

<p><strong>Vector Examples</strong></p>

<pre><code>// Fixed size vector
let x : [uint, ..10] = [5, ..10]; // [5,5,5,5,5,5,5,5,5,5]

// Create a variable size owned vector
let mut numbers1 : ~[uint]= ~[0, 1, 2, 3, 4, 5];

// Create a variable size borrowed vector. This is also called a &quot;vector slice&quot;.
let mut numbers2 : &amp;[uint]= &amp;[0, 1, 2];
let mut slice: &amp;[uint] = numbers1.slice(0, 3);
</code></pre>

<h3 id="strings-and-characters">Strings and characters</h3>

<p>Some string types include: <code>&amp;str</code>, <code>~str</code>, and <code>&amp;'static str</code>.</p>

<p>A string is represented internally as a vector of bytes. However,
<code>str</code> by itself is <em>not</em> a type, and there are no fixed-size strings.
You can convert any of the string types to a byte vector <code>&amp;[u8]</code>.</p>

<p><code>char</code> is a 32-bit Unicode character.</p>

<p><strong>String Examples</strong></p>

<pre><code>use std::option::Option;
// Static string
let hello: &amp;'static str = &quot;Hello!&quot;;
let hello2: &amp;str = &quot;Hello!&quot;;

// Owned string
let owned_hello: ~str = ~&quot;Hello!&quot;;

// Borrowed string
let borrowed_hello = &amp;owned_hello;

// Character
let c: char = 'a';

// Indexing into a string gives you a byte, not a character.
let byte: u8 = owned_hello[1];

// You need to create an iterator to get a character from a string.
let c: Option&lt;char&gt; = owned_hello.chars().nth(2);

// Switch to the string's representation as bytes
let bytes: &amp;[u8] = owned_hello.as_bytes();
</code></pre>

<h3 id="functions">Functions</h3>

<p>For a function <code>fn(a: A) -&gt; B</code></p>

<p><code>fn(A)-&gt;B</code> is a type, So are <code>&amp;(fn(A)-&gt;B)</code>, <code>~(fn(A)-&gt;B)</code>, but you need to add parens right now.</p>

<p>You probably only want to use <code>fn(A)-&gt;B</code>, though.</p>

<p><strong>Function type examples</strong></p>

<pre><code>fn foo(a: int) -&gt; f32 {
    return 0.0;
}
let bar: fn(int) -&gt; f32 = foo; 
let baz: &amp;(fn(int) -&gt; f32) = &amp;foo;
</code></pre>

<h3 id="closures">Closures</h3>

<p>The type of a closure mapping something of type <code>A</code> to type <code>B</code> is <code>|A| -&gt; B</code>. A closure with no arguments or return values has type <code>||</code>.</p>

<p><strong>Closure type examples</strong></p>

<pre><code>let captured_var = 10; 
let closure_no_args = || println!(&quot;captured_var={}&quot;, captured_var); 
let closure_args = |arg: int| -&gt; int {
  println!(&quot;captured_var={}, arg={}&quot;, captured_var, arg); 
  arg
};

// closure_no_args has type ||
// closure_args has type |int| -&gt; int

fn call_closure(c1: ||, c2: |int| -&gt; int) {
  c1();
  c2(2);
}

call_closure(closure_no_args, closure_args);
</code></pre>

<h3 id="raw-pointers">Raw pointers</h3>

<p>For any type <code>T</code>, <code>*T</code> is a type.</p>

</div>
<footer>
<div class="sharing">
<a href="http://twitter.com/share" class="twitter-share-button" data-url="https://jvns.ca/blog/2013/12/02/types-in-rust/" data-via="b0rk" data-counturl="https://jvns.ca/blog/2013/12/02/types-in-rust/">Tweet</a>
</div>
<p class="meta">
   
    <a class="basic-alignment left" href="https://jvns.ca/blog/2013/12/03/day-36-programming-without-malloc/" title="Previous Post: Day 36: On programming without malloc">Day 36: On programming without malloc</a>
  
   
    <a class="basic-alignment right" href="https://jvns.ca/blog/2013/12/01/how-to-call-rust-from-assembly/" title="Previous Post: How to call Rust from assembly, and vice versa">How to call Rust from assembly, and vice versa</a>
  
</p>
</footer>
</article>
</div>

</div>
</div>
<nav role="navigation" class="footer-nav"> <a href="/">Archives</a>
</nav>
<footer role="contentinfo"><span class="credit">&copy; 2016 Polina Soshnin.
</footer>
</div>
</body>
</html>

