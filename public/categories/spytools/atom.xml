<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Julia Evans]]></title>
  <link href="http://jvns.ca/atom.xml" rel="self"/>
  <link href="https://jvns.ca/categories/spytools/atom/index.xml"/>
  <updated>0001-01-01T00:00:00+00:00</updated>
  <id>http://jvns.ca</id>
  <author>
    <name><![CDATA[Julia Evans]]></name>
  </author>
  <generator uri="http://gohugo.io/">Hugo</generator>

  
  <entry>
    <title type="html"><![CDATA[A zine about strace]]></title>
    <link href="https://jvns.ca/blog/2015/04/14/strace-zine/"/>
    <updated>2015-04-14T22:52:23+00:00</updated>
    <id>https://jvns.ca/blog/2015/04/14/strace-zine/</id>
    <content type="html"><![CDATA[<p><strong>UPDATE</strong>: this zine and more can now be found at <a href="https://jvns.ca/zines">jvns.ca/zines</a></p>

<p>As some of you might have heard, I wrote a zine to teach people about
how to debug their programs using strace a while ago! I was originally
going to mail it out to people, but it turns out I&rsquo;m too lazy to mail
anything.</p>

<p>So instead, you can download, print, fold, and staple it yourself today!
It should work if you print it double-sided with short edge binding on
letter paper. Also if you print an initial master copy, you can take it
to a copy shop and get them to make many copies for you.</p>

<p>Give it to your friends/colleagues/students to teach them about strace!
Send me pictures! <a href="https://twitter.com/b0rk">Tell me</a> what you think! &lt;3</p>

<p><a href="http://jvns.ca/strace-zine-portrait.pdf">Here&rsquo;s the pdf. Have fun.</a> (there&rsquo;s also a <a href="http://jvns.ca/strace-zine-landscape.pdf">landscape version</a>)</p>

<p>You can also <a href="http://jvns.ca/strace-zine-unfolded.pdf">read it on your computer</a>. But printing it is better! =D</p>

<div align="center">
<a href="http://jvns.ca/strace-zine-portrait.pdf">
<img src="/images/strace_zine.png">
</a>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A few spy tools for your operating system (other than strace!)]]></title>
    <link href="https://jvns.ca/blog/2015/04/06/a-few-spy-tools-for-your-operating-system-other-than-strace/"/>
    <updated>2015-04-06T22:30:02+00:00</updated>
    <id>https://jvns.ca/blog/2015/04/06/a-few-spy-tools-for-your-operating-system-other-than-strace/</id>
    <content type="html"><![CDATA[<p>There are <em>so many</em> awesome tools you can use to find out what&rsquo;s going on with
your computer. Here are some that exist on Linux. They might exist on your OS
too!</p>

<h3 id="netstat">netstat</h3>

<p>netstat tells you what ports are open on your computer. This is crazy useful if
you want to know if the service that is <em>supposed</em> to be listening on port 8080
is <em>actually</em> listening on port 8080.</p>

<pre><code>sudo netstat -tulpn
[sudo] password for bork: 
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address       Foreign Address     State       PID/Program name
tcp        0      0 127.0.0.1:631       0.0.0.0:*           LISTEN      1658/cupsd      
tcp        0      0 127.0.0.1:5432      0.0.0.0:*           LISTEN      1823/postgres   
tcp        0      0 127.0.0.1:6379      0.0.0.0:*           LISTEN      2516/redis-server
</code></pre>

<p>If you look at the Program Name column on the right, you&rsquo;ll see that
apparently I have cupsd (printing), postgres, and redis servers running
on my machine, as well as some other stuff that I redacted. I actually
have no idea why I had redis installed so uh yeah I uninstalled it.</p>

<p>I use netstat pretty often when I&rsquo;m trying to debug &ldquo;omg why is this
thing not running IT IS SUPPOSED TO BE RUNNING&rdquo;. netstat tells me the
truth about whether it is running.</p>

<p></p>

<h3 id="dstat">dstat</h3>

<p>Want to know how much data is actually being written to your physical hard
drive right this second? YEAH YOU DO. dstat knows that. It prints a row every
second with stats for that second. I love dstat because it&rsquo;s so simple.</p>

<pre><code>----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw 
 32  38  30   0   0   0|  28k   81k|   0     0 |   4B  123B| 441  2184 
 12  29  59   0   0   0|   0   184k|  66B   86B|   0     0 |1428  6031 
  9  26  65   0   0   0|   0   576k| 518B  528B|   0     0 |1157  4611 
  9  25  66   0   0   0|   0   144k|   0     0 |   0     0 |1100  5249 
 14  27  59   0   0   0|   0     0 |  60B    0 |   0     0 |1001  4285 
  9  29  62   0   0   0|   0   180k| 122B   82B|   0     0 |1166  5416
</code></pre>

<h3 id="lsof">lsof</h3>

<p>lsof tells you which files every process has open right now! That&rsquo;s all!
It is awesome the same way dstat and netstat are awesome &ndash; you want to
know what files are open right now, it tells you what files are open
right now, you&rsquo;re done &lt;3.</p>

<p>It can also tell you what position in the file the process is at, so you
can find out what kind of progress it&rsquo;s making reading the file.</p>

<h3 id="ngrep-tcpdump">ngrep / tcpdump</h3>

<p>Okay now we&rsquo;re moving from &ldquo;super simple tool that does one thing&rdquo; to
&ldquo;tcpdump that has a billion options and also this whole BPF berkeley
packet filter business and what is this filter language even&rdquo;. So I&rsquo;m
not going to explain how to use tcpdump because I don&rsquo;t even really
know.</p>

<p>Let&rsquo;s say you want to</p>

<ul>
<li>reverse engineer a protocol</li>
<li>find out if there&rsquo;s <em>really</em> terrible latency or if everything is slow for some other reason</li>
<li>debug why your POST request is formatted wrong in a world before google chrome dev tools</li>
</ul>

<p>To do all of this, you need to spy on network activity! ngrep and tcpdump
capture packets, let you filter them, and show you what you&rsquo;re looking for. I&rsquo;m
not going to explain how to use them here but <a href="http://dl.packetstormsecurity.net/papers/general/ngreptut.txt">this ngrep tutorial</a> looks
pretty useful. If you&rsquo;re looking at output from tcpdump you should probably
dump it to a pcap file and use Wireshark to look at it instead. Wireshark is
the best and way easier to understand because it&rsquo;s a GUI and it makes
everything pretty for you.</p>

<p>as always with these systems tools, ngrep / tcpdump will tell you The Truth™
about what&rsquo;s going on on your network.</p>

<p>If you want to know how people use tcpdump, you should read <a href="https://twitter.com/b0rk/status/585234410980712448">the replies to this tweet &ldquo;do you use tcpdump in your day-to-day life? what do you use it for?&rdquo;</a> because the people
who follow me on twitter are the best. Really go read them! There is so much
interesting stuff there.</p>

<h3 id="opensnoop-ftrace">opensnoop &amp; ftrace</h3>

<p>Do you want to know every file your system is opening right now? There&rsquo;s a
script in Brendan Gregg&rsquo;s
<a href="https://github.com/brendangregg/perf-tools">perf-tools</a> collection that does
that!</p>

<p>I&rsquo;m mostly including this as an example to show that a lot of stuff is
<em>possible</em> to know &ndash; the scripts in that repo don&rsquo;t work with every Linux kernel
version (I needed to <a href="https://github.com/brendangregg/perf-tools/pull/24">modify it</a>
to get it to work with Linux 3.13). But they use a tracing framework in
the Linux kernel called &lsquo;ftrace&rsquo; that can tell you all <em>kinds</em> of stuff.</p>

<p>ftrace seems like quite a bit of work to learn how to use, but also really
powerful. Basically you access it by doing various things to files in
<code>/sys/kernel/debug/tracing</code>, or by using a wrapper command called
<code>trace-cmd</code>. It&rsquo;s all built into Linux!</p>

<h3 id="atop">atop</h3>

<p>atop is like top, but it shows you more stuff and you need to run it as
root. So it&rsquo;ll show me the CPU &amp; memory usage for each process, but also
how much disk &amp; network I/O it&rsquo;s doing. It&rsquo;s neat and a little
terrifying to look at at first (SO MANY NUMBERS).</p>

<h3 id="wow">wow</h3>

<p>That&rsquo;s all for now! If you have other tools you frequently reach for
when trying to figure out what&rsquo;s going on on your system, I&rsquo;d be
interested to know what they are. <a href="https://twitter.com/b0rk">@b0rk</a> on
Twitter, as always :)</p>

<p>an aside &ndash; I&rsquo;ve been thinking about man pages recently, and how you can
read the man page for tcpdump and understand individually all the words,
but it&rsquo;s not a substitute for someone telling you an Awesome Story about
how they used tcpdump to debug an intermittent certificate problem or a
DNS problem and then they Saved the Day.</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LD_PRELOAD is super fun. And easy!]]></title>
    <link href="https://jvns.ca/blog/2014/11/27/ld-preload-is-super-fun-and-easy/"/>
    <updated>2014-11-27T22:51:27+00:00</updated>
    <id>https://jvns.ca/blog/2014/11/27/ld-preload-is-super-fun-and-easy/</id>
    <content type="html"><![CDATA[<p>On Monday I went to Hacker School, and as always it was the most fun
time. I hung out with <a href="http://blog.chaselambda.com/">Chase</a> and we had
fun with dynamic linkers!</p>

<p>I&rsquo;d been hearing for a while that you can override arbitrary function
calls in a program using an environment variable called <code>LD_PRELOAD</code>.
But I didn&rsquo;t realize how easy it was! Chase and I started using it and
we got it working in, like, 5 minutes!</p>

<p>I googled &ldquo;LD_PRELOAD hacks&rdquo;, clicked on <a href="http://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/">Dynamic linker tricks: Using LD_PRELOAD to cheat, inject features and investigate programs</a>,
and we were up and running.</p>

<p>The first example on that page has you write a new random function that
always returns 42.</p>

<pre><code>int rand(){
    return 42; //the most random number in the universe
}
</code></pre>

<p>That is LITERALLY ALL THE CODE YOU HAVE TO WRITE. Then you</p>

<pre><code>gcc -shared -fPIC unrandom.c -o unrandom.so
export LD_PRELOAD=unrandom.so
</code></pre>

<p>and now every program you run will always return 42 for rand()!</p>

<p></p>

<p>We did a bunch of investigations into how tmux works, which was super
fun. <a href="http://blog.chaselambda.com/2014/11/25/how-tmux-starts-up-an-adventure-with-linux-tools.html">Chase wrote it up on his blog</a>,
and now I understand about daemonization way better.</p>

<p>We very quickly ran into the question of &ldquo;okay, what if you want to call
the original <code>printf</code>?&rdquo; from your hacked printf? That&rsquo;s also explained
in the &ldquo;Dynamic linker tricks&rdquo; article! (in the &ldquo;Being transparent&rdquo;
section, using <code>dlsym</code>)</p>

<p>Somebody explained to me at some point that if you work for the NSA and
you&rsquo;re trying to spy on what information a program is using internally,
tools like LD_PRELOAD are VERY USEFUL.</p>

<h3 id="how-it-works">How it works</h3>

<p>There is a very wonderful
<a href="http://lwn.net/Articles/276782/">20 part series about linkers</a> that I
am going to keep recommending to everyone forever.</p>

<p>When you start a dynamically linked program, it doesn&rsquo;t have all the
code for the functions it needs! So what happens is:</p>

<ul>
<li>the program gets loaded into memory</li>
<li>the dynamic linker figures out which other libraries that program
needs to run (<code>.so</code> files)</li>
<li>it loads them into memory, too!</li>
<li>it connects everything up</li>
</ul>

<p><code>LD_PRELOAD</code> is an environment variable that says &ldquo;Whenever you look for
a function name, look in me first!&ldquo;. So if you didn&rsquo;t want your program
to be attacked like this, you could:</p>

<ul>
<li>statically link your program</li>
<li>check for the <code>LD_PRELOAD</code> environment variable, and complain (though
the attacker could also LD_PRELOAD the function that lets you read
environment variables&hellip; :) )</li>
</ul>

<p>I&rsquo;m sure there will be more Exciting Stories about LD_PRELOAD for you
all in the future, but this is all the stories I have for today.</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I can spy on my CPU cycles with perf!]]></title>
    <link href="https://jvns.ca/blog/2014/05/13/profiling-with-perf/"/>
    <updated>2014-05-13T20:47:49+00:00</updated>
    <id>https://jvns.ca/blog/2014/05/13/profiling-with-perf/</id>
    <content type="html"><![CDATA[<p>Yesterday I talked about using <code>perf</code> to profile assembly
instructions. Today I learned how to make flame graphs with <code>perf</code>
today and it is THE BEST. I found this because
<a href="https://twitter.com/graydon_moz">Graydon Hoare</a> pointed me to Brendan
Gregg&rsquo;s <em>excellent</em>
<a href="http://www.brendangregg.com/perf.html">page on how to use perf</a>.</p>

<p>Wait up! What&rsquo;s <code>perf</code>? I&rsquo;ve talked about <code>strace</code> a lot before (in
<a href="http://jvns.ca/blog/2014/04/20/debug-your-programs-like-theyre-closed-source/">Debug your programs like they&rsquo;re closed source</a>).
<code>strace</code> lets you see which system calls a program is calling. But
what if you wanted to know</p>

<ul>
<li>how many CPU instructions it ran?</li>
<li>How many L1 cache misses there were?</li>
<li>profiling information for each assembly instruction?</li>
</ul>

<p><code>strace</code> only does system calls, and none of those things are system
calls. So it can&rsquo;t tell you any of those things!</p>

<p></p>

<p><code>perf</code> is a Linux tool that can tell you all of these things, and
more! Let&rsquo;s run a quick example on the
<a href="http://jvns.ca/blog/2014/05/12/computers-are-fast/">bytesum program from yesterday</a>.</p>

<pre>
bork@kiwi ~/w/howcomputer> perf stat ./bytesum_mmap *.mp4
 Performance counter stats for './bytesum_mmap The Newsroom S01E04.mp4':

        158.141639 task-clock                #    0.994 CPUs utilized          
                22 context-switches          #    0.139 K/sec                  
                 9 CPU-migrations            #    0.057 K/sec                  
               133 page-faults               #    0.841 K/sec                  
       438,662,273 cycles                    #    2.774 GHz                     [82.43%]
       269,916,782 stalled-cycles-frontend   #   61.53% frontend cycles idle    [82.38%]
       131,557,379 stalled-cycles-backend    #   29.99% backend  cycles idle    [66.66%]
       681,518,403 instructions              #    1.55  insns per cycle        
                                             #    0.40  stalled cycles per insn [84.88%]
       130,568,804 branches                  #  825.645 M/sec                   [84.85%]
            20,756 branch-misses             #    0.02% of all branches         [83.68%]

       0.159154389 seconds time elapsed
</pre>

<p>This is super neat information, and there&rsquo;s a lot more (see <code>perf
list</code>). But we can do even more fun things!</p>

<h3 id="flame-graphs-with-perf">Flame graphs with perf</h3>

<p>I wanted to profile my <code>bytesum</code> program. But how do you even profile
C programs? Here&rsquo;s a way to do it with <code>perf</code>:</p>

<pre>
sudo perf record -g ./bytesum_mmap *.mp4
sudo perf script | stackcollapse-perf.pl | flamegraph.pl > flamegraph.svg
</pre>

<p>Here&rsquo;s the SVG this gave me:</p>

<p><img src="/images/flamegraph.svg"></p>

<p>This is AMAZING. But what does it mean? Basically <code>perf</code> periodically
interrupts the program and finds out where in the stack it is. The
width of each part of the stack in the graph above is the proportion
of samples that happened there. (so about 30% of the execution time
was spend in <code>main</code>). I don&rsquo;t know what the colour means here.</p>

<p>We can see that there are 3 big parts &ndash; there&rsquo;s the <code>mmap</code> call (on
the left), the main program execution (in the middle), and the
<code>sys_exit</code> part on the right. Apparently stopping my program takes a
long time! Neat!</p>

<p>But there&rsquo;s more!</p>

<h3 id="is-it-really-l1-cache-misses-we-can-find-out">Is it really L1 cache misses? We can find out!</h3>

<p>So yesterday I made a program with really bad memory access patterns
(<a href="https://github.com/jvns/howcomputer/blob/master/bytesum_stride.c">bytesum_stride.c</a>),
and I conjectured that it was way slower because it was causing way
too many L1 cache misses.</p>

<p>But with <code>perf</code>, we can check if that&rsquo;s actually true! Here are the
results (reformatted a bit to be more compact):</p>

<pre>
bork@kiwi ~/w/howcomputer> perf stat -e L1-dcache-misses,L1-dcache-loads ./bytesum_mmap *.mp4
        17,175,214 L1-dcache-misses #   11.48% of all L1-dcache hits  
       149,568,438 L1-dcache-loads
bork@kiwi ~/w/howcomputer> perf stat -e L1-dcache-misses,L1-dcache-loads ./bytesum_stride *.mp4 1000
     1,031,902,483 L1-dcache-misses #  193.16% of all L1-dcache hits  
       534,219,219 L1-dcache-loads
</pre>

<p>So, uh, that&rsquo;s really bad. We now have <strong>60 times more</strong> L1 cache
misses, and also 3 times more hits.</p>

<h3 id="other-amazing-things">Other amazing things</h3>

<ul>
<li>Go to
<a href="http://www.brendangregg.com/perf.html">Brendan Gregg&rsquo;s perf page and read the whole thing</a>.
Also possibly everything he&rsquo;s ever written. His recent post on
<a href="http://www.brendangregg.com/blog/2014-05-11/strace-wow-much-syscall.html">strace</a>
is great too.</li>
<li>The <a href="https://perf.wiki.kernel.org/index.php/Tutorial">perf tutorial</a>
is pretty long, but I found it somewhat helpful.</li>
<li><a href="https://github.com/brendangregg/FlameGraph">FlameGraph!</a></li>
<li>I spent a little bit of time running cachegrind with
<code>valgrind --tool=cachegrind ./bytesum_mmap my_file</code>
which can give you possibly even more information about CPU caches
than <code>perf</code> can. Still haven&rsquo;t totally wrapped my head around this.</li>
</ul>

<p>There are still so many things I don&rsquo;t understand at all!</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recovering files using /proc (and spying, too!)]]></title>
    <link href="https://jvns.ca/blog/2014/03/23/recovering-files-using-slash-proc-and-other-useful-facts/"/>
    <updated>2014-03-23T11:16:24+00:00</updated>
    <id>https://jvns.ca/blog/2014/03/23/recovering-files-using-slash-proc-and-other-useful-facts/</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve had a vague idea for years that /proc was a way the Linux kernel
exposed its internals, and that I could look there to find things.</p>

<p>Then I learned this:</p>

<blockquote class="twitter-tweet" lang="en"><p>TIL!!! If you
accidentally delete a file that a process still has open, you can
recover it with cat /proc/$pid/fd/$file_descriptor. so
easy!</p>&mdash; Julia Evans (@b0rk) <a
href="https://twitter.com/b0rk/statuses/446291944575352833">March 19,
2014</a></blockquote>

<p>Suddenly it was like <code>/proc</code> was turned into a magical unicorn! I can
use it to recover my files?! ★★Amazing★★.</p>

<p>Let&rsquo;s explain why this works. When a process opens a file (including
sockets), it gets a <em>file descriptor</em> for that file, which is a number
starting at 0.</p>

<p></p>

<h3 id="file-descriptors-and-investigations-on-std-in-out-err">File descriptors and investigations on std{in,out,err}</h3>

<p>0, 1, and 2 are always the stdin, stdout, and stderr of the process.
For example, if I look at the file descriptors for a Google Chrome
process I have, I see:</p>

<pre>
$ ls /proc/4076/fd
0  10  12  14  16  18  2   21  23  26  28  3   31  34  36  38  4   41  43  5   6  72  8
1  11  13  15  17  19  20  22  25  27  29  30  32  35  37  39  40  42  44  53  7  74  9
</pre>

<p>That&rsquo;s pretty opaque! Let&rsquo;s take a closer look.</p>

<pre>
$ ls -l /proc/4076/fd/{0,1,2}
lr-x------ 1 bork bork 64 Mar 22 22:38 /proc/4076/fd/0 -> /dev/null
l-wx------ 1 bork bork 64 Mar 22 22:38 /proc/4076/fd/1 -> /dev/null
l-wx------ 1 bork bork 64 Mar 22 22:38 /proc/4076/fd/2 -> /home/bork/.xsession-errors
</pre>

<p>Neat, the numbers 0, 1, and 2 are just symbolic links! It looks like
Chrome doesn&rsquo;t have any stdin or stdout, which makes sense, but the
stderr is <code>/home/bork/.xsession-errors</code>. I didn&rsquo;t know that! It turns
out this is also a great way to find out where a process that you
didn&rsquo;t start is redirecting its output.</p>

<p>Where else do my programs redirect their stderr? Let&rsquo;s see! I looked
at everything&rsquo;s stderr, got awk to pull out just the file, and ran
<code>uniq</code> to get the counts.</p>

<pre>
$ ls -l /proc/*/fd/2 | awk '{print $11}' | sort | uniq -c
      42 /dev/null
      2 /dev/pts/0
      1 /dev/pts/1
      3 /dev/pts/2
      2 /dev/pts/3
      2 /dev/pts/4
      5 /dev/pts/5
      1 /dev/pts/7
     25 /home/bork/.xsession-errors
</pre>

<p>So mostly /dev/null, some of them are running on terminals
(<code>/dev/pts/*</code>), and the rest to <code>~/.xsession-errors</code>. No huge
surprises here.</p>

<p>What else could we use these file descriptors for? Someone on Twitter
suggested this:</p>

<blockquote class="twitter-tweet" data-conversation="none"
lang="en"><p><a href="https://twitter.com/b0rk">@b0rk</a> When I was
making my first Tarsnap backup, I used `readlink
/proc/&lt;TARSNAP&gt;/fd/7` in a loop to find out what file it was
on.</p> &mdash; Matthew Frazier (@LeafStorm) <a
href="https://twitter.com/LeafStorm/statuses/447564888198885376">March
23, 2014</a></blockquote>

<p>This works because when you open different files again and again in a
loop, it will usually end up with the same file descriptor. You could
also do the same thing by running <code>strace -etrace=open -p$TARSNAP_PID</code>
to see which files Tarsnap is opening.</p>

<p>Okay, now we know that we can use /proc to learn about our processes&rsquo;
files! What else?</p>

<h3 id="spy-on-your-processes-with-proc-pid-status">Spy on your processes with /proc/$pid/status</h3>

<p>If you look at the file <code>/proc/$pid/status</code>, you can find out all
sorts of information about your processes! You can look at this for
any process.</p>

<p>Here&rsquo;s a sample of what&rsquo;s in that file:</p>

<pre>
Name:   chrome
Groups: 4 20 24 27 30 46 104 109 124 1000 
VmPeak:   853984 kB
VmSize:   670392 kB
VmData:   323264 kB
VmExe:     96100 kB
Threads:        3
Cpus_allowed_list:      0-7
</pre>

<p>So we can see there&rsquo;s some information about the memory, its name, its
groups, its threads, and which CPUs it&rsquo;s allowed to run on.</p>

<p>But wait! We could have found out a lot of this information with <code>ps
aux</code>. How does <code>ps</code> do it? Let&rsquo;s find out!</p>

<pre>
$ strace -f -etrace=open ps aux
...
open("/proc/30219/stat", O_RDONLY)      = 6
open("/proc/30219/status", O_RDONLY)    = 6
open("/proc/30219/cmdline", O_RDONLY)   = 6
...
</pre>

<p>So <code>ps</code> gets its information from <code>/proc</code>! Neat.</p>

<h3 id="i-m-sold-what-else-is-there">I&rsquo;m sold. What else is there?!!</h3>

<p>I tweeted asking for suggestions of things to find in <code>/proc/</code>, and
someone replied linking to the
<a href="http://linux.die.net/man/5/proc">/proc man page</a>. I thought they were
trolling me, but then I clicked on it and it was actually useful!</p>

<p>A few more things I need to investigate:</p>

<ul>
<li>the <code>procps</code> and <code>sysstat</code> utilities</li>
<li>a ton of wonderful suggestions by Keegan McAllister on the
<a href="https://blogs.oracle.com/ksplice/entry/solving_problems_with_proc">Ksplice blog</a>
(including how to force a program to take stdin if it doesn&rsquo;t take
stdin)</li>
<li><code>/sys</code> replaces part of <code>/proc</code>&rsquo;s functionality.</li>
<li>Plan 9 / Inferno took this &ldquo;everything is a file&rdquo; business even more
seriously than Linux does</li>
<li><a href="https://en.wikipedia.org/wiki/Debugfs">debugfs</a> / ftrace.
<a href="http://thread.gmane.org/gmane.linux.kernel.mmc/4248/focus=4400">An example someone linked to.</a></li>
</ul>

<p>I still feel like there are concrete uses for <code>/proc/</code> that I don&rsquo;t
know about, though. What are they?</p>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Three steps to learning GDB]]></title>
    <link href="https://jvns.ca/blog/2014/02/10/three-steps-to-learning-gdb/"/>
    <updated>2014-02-10T00:00:00+00:00</updated>
    <id>https://jvns.ca/blog/2014/02/10/three-steps-to-learning-gdb/</id>
    <content type="html"><![CDATA[<p>Debugging C programs used to scare me a lot. Then I was writing my
<a href="http://jvns.ca/blog/categories/kernel">operating system</a> and I had so
many bugs to debug! I was extremely fortunate to be using the emulator
qemu, which lets me attach a debugger to my operating system. The
debugger is called <code>gdb</code>.</p>

<p>I&rsquo;m going to explain a couple of small things you can do with <code>gdb</code>,
because I found it really confusing to get started. We&rsquo;re going to set
a breakpoint and examine some memory in a tiny program.</p>

<p></p>

<h3 id="1-set-breakpoints">1. Set breakpoints</h3>

<p>If you&rsquo;ve ever used a debugger before, you&rsquo;ve probably set a
breakpoint.</p>

<p>Here&rsquo;s the program that we&rsquo;re going to be &ldquo;debugging&rdquo; (though there
aren&rsquo;t any bugs):</p>

<pre><code>#include &lt;stdio.h&gt;
void do_thing() {
    printf(&quot;Hi!\n&quot;);
}
int main() {
    do_thing();
}
</code></pre>

<p>Save this as <code>hello.c</code>. We can debug it with gdb like this:</p>

<pre>
bork@kiwi ~> gcc -g hello.c -o hello
bork@kiwi ~> cat
bork@kiwi ~> gdb ./hello
</pre>

<p>This compiles <code>hello.c</code> with debugging symbols (so that gdb can do
better work), and gives us kind of scary prompt that just says</p>

<p><code>(gdb)</code></p>

<p>We can then set a breakpoint using the <code>break</code> command, and then <code>run</code>
the program.</p>

<pre>
(gdb) break do_thing 
Breakpoint 1 at 0x4004f8
(gdb) run
Starting program: /home/bork/hello 

Breakpoint 1, 0x00000000004004f8 in do_thing ()
</pre>

<p>This stops the program at the beginning of <code>do_thing</code>.</p>

<p>We can find out where we are in the call stack with <code>where</code>: (thanks
to <a href="https://twitter.com/mgedmin">@mgedmin</a> for the tip)</p>

<pre>
(gdb) where
#0  do_thing () at hello.c:3
#1  0x08050cdb in main () at hello.c:6
(gdb) 
</pre>

<h3 id="2-look-at-some-assembly-code">2. Look at some assembly code</h3>

<p>We can look at the assembly code for our function using the
<code>disassemble</code> command! This is cool. This is x86 assembly. I don&rsquo;t
understand it very well, but the line that says <code>callq</code> is what does
the <code>printf</code> function call.</p>

<pre>
(gdb) disassemble do_thing
Dump of assembler code for function do_thing:
   0x00000000004004f4 <+0>:     push   %rbp
   0x00000000004004f5 <+1>:     mov    %rsp,%rbp
=> 0x00000000004004f8 <+4>:     mov    $0x40060c,%edi
   0x00000000004004fd <+9>:     callq  0x4003f0 <puts@plt>
   0x0000000000400502 <+14>:    pop    %rbp
   0x0000000000400503 <+15>:    retq 
</pre>

<p>You can also shorten <code>disassemble</code> to <code>disas</code></p>

<h3 id="3-examine-some-memory">3. Examine some memory!</h3>

<p>The main thing I used <code>gdb</code> for when I was debugging my kernel was to
examine regions of memory to make sure they were what I thought they
were. The command for examining memory is <code>examine</code>, or <code>x</code> for short.
We&rsquo;re going to use <code>x</code>.</p>

<p>From looking at that assembly above, it seems like <code>0x40060c</code> might be
the address of the string we&rsquo;re printing. Let&rsquo;s check!</p>

<pre>
(gdb) x/s 0x40060c
0x40060c:        "Hi!"
</pre>

<p>It is! Neat! Look at that. The <code>/s</code> part of <code>x/s</code> means &ldquo;show it to me
like it&rsquo;s a string&rdquo;. I could also have said &ldquo;show me 10 characters&rdquo;
like this:</p>

<pre>
(gdb) x/10c 0x40060c
0x40060c:       72 'H'  105 'i' 33 '!'  0 '\000'        1 '\001'        27 '\033'       3 '\003'        59 ';'
0x400614:       52 '4'  0 '\000'
</pre>

<p>You can see that the first four characters are &lsquo;H&rsquo;, &lsquo;i&rsquo;, and &lsquo;!&rsquo;, and
&lsquo;\0&rsquo; and then after that there&rsquo;s more unrelated stuff.</p>

<p>I know that gdb does lots of other stuff, but I still don&rsquo;t know it
very well and <code>x</code> and <code>break</code> got me pretty far. You can read the
<a href="http://ftp.gnu.org/old-gnu/Manuals/gdb-5.1.1/html_chapter/gdb_9.html#SEC56">documentation for examining memory</a>.</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 44: qemu &#43; gdb = so great]]></title>
    <link href="https://jvns.ca/blog/2013/12/17/day-44-gdb-is-great/"/>
    <updated>2013-12-17T00:00:00+00:00</updated>
    <id>https://jvns.ca/blog/2013/12/17/day-44-gdb-is-great/</id>
    <content type="html"><![CDATA[<p>Today I did some more debugging and cleaning up. Previously I was
setting up my IDT (interrupt descriptor table) with assembly, but I
wanted to do it with Rust, because I don&rsquo;t really know assembly and
the less of it I have in my OS, the less of a liability it is. I&rsquo;d
tried to do this before, but it wasn&rsquo;t working.</p>

<p>What turned out to be wrong:</p>

<ul>
<li>I had <code>1 &lt;&lt; 16 - 1</code> instead of <code>(1 &lt;&lt; 16) - 1</code>, so my mask wasn&rsquo;t
working properly</li>
<li>I had the wrong function name for the interrupt handler</li>
<li>That was it!</li>
</ul>

<p>This actually ended up being really easy to debug! &ldquo;Really easy&rdquo; as in
&ldquo;it took all day, but I did not feel like hiding under the table at
any point&rdquo;. I have a symbol table, and <code>idt</code> is in it, so I just
needed to do iterations on</p>

<pre><code>gdb) x/4x &amp;idt
</code></pre>

<p>and compare the contents of memory from Working Code with the
Non-Working Code.</p>

<p><code>x/</code> means &ldquo;examine&rdquo;, and <code>4x</code> means &ldquo;as hex, 4 times`. Here&rsquo;s some
<a href="https://sourceware.org/gdb/onlinedocs/gdb/Memory.html">documentation for examining memory</a>.</p>

<p>Comparing sections of memory and figuring out why they&rsquo;re wrong is
tedious, but pretty straightforward &ndash; I had a good handle on what
all my code was doing. Pretty exciting. Best friends, gdb.</p>

<p><code>gdb</code> isn&rsquo;t totally the best interface &ndash; I can certainly imagine
having better ones. But it is Very Useful. So far I know how to</p>

<ul>
<li>Find the address of a symbol in memory</li>
<li>Look at memory (as ints, as hex, as ASCII)</li>
<li>Search memory</li>
<li>Set breakpoints (and look at assembly that I don&rsquo;t understand)</li>
<li>Make core dumps to look at later</li>
</ul>

<p>These are pretty awesome superpowers already, and I&rsquo;m sure there are
tons more.</p>

<p>So now my interrupt handlers are set up in Rust! This will make it
much easier for me to implement <code>int 80</code>, and therefore move towards
being able to run programs! Excellent! Onwards!</p>
]]></content>
  </entry>
  
</feed>