<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Julia Evans]]></title>
  <link href="http://jvns.ca/atom.xml" rel="self"/>
  <link href="https://jvns.ca/categories/containers/atom/index.xml"/>
  <updated>0001-01-01T00:00:00+00:00</updated>
  <id>http://jvns.ca</id>
  <author>
    <name><![CDATA[Julia Evans]]></name>
  </author>
  <generator uri="http://gohugo.io/">Hugo</generator>

  
  <entry>
    <title type="html"><![CDATA[What happens when you run a rkt container?]]></title>
    <link href="https://jvns.ca/blog/2016/11/03/what-happens-when-you-run-a-rkt-container/"/>
    <updated>2016-11-03T22:45:16+00:00</updated>
    <id>https://jvns.ca/blog/2016/11/03/what-happens-when-you-run-a-rkt-container/</id>
    <content type="html"><![CDATA[

<p>I’ve been learning a lot about <a href="https://coreos.com/rkt">rkt</a> recently. rkt (&ldquo;rocket&rdquo;) is a program that lets you run containers. In <a href="/blog/2016/10/10/what-even-is-a-container/">what even is a container?</a>, we talked about how running a container can be &ldquo;basically&rdquo; just the same as running a process. You just run that process with a different view of the filesystem (using &ldquo;namespaces&rdquo;).</p>

<p>I’ve claimed previously on this blog that rkt &ldquo;just runs programs, it’s not
that complicated, that’s why it’s cool&rdquo;. But if you look at the source for rkt,
excluding tests, there are about 34,000 lines of Go code today. That’s not a
huge huge project, but it’s not trivial! What are all those 34,000 lines doing?</p>

<p>Since I’m trying to use rkt pretty seriously right now, I’d like to understand
its architecture. Let’s find out what rkt does when it runs a container!</p>

<p>I claimed somewhat boldly on twitter that this would &ldquo;explain every system call
that happens in rkt&rdquo;. That was somewhat of an overstatement &ndash; I picked command
line options to rkt so that it runs as few system calls as possible, and then
even so there are too many to understand in 2 days :) But that&rsquo;s the spirit of
what I&rsquo;m trying to do here &ndash; really understand exactly what rkt is doing.</p>

<p>There&rsquo;s some pretty good <a href="https://github.com/coreos/rkt/blob/master/Documentation/devel/architecture.md">architecture documentation</a> that I referred to a bunch and explains a bunch of things that I do not explain here.</p>

<p>As usual there are probably things in here that are wrong.</p>

<p><strong>What running a container looks like in rkt</strong></p>

<p>When you run a rkt container, it looks like this:</p>

<pre><code>sudo rkt run julia.com/some_image
</code></pre>

<p>That looks pretty simple! But a lot of things need to happen for this to work.</p>

<h1 id="part-1-fetch">Part 1: FETCH</h1>

<p>To get a container, first you need to put the files on disk somewhere! This is
actually pretty involved.</p>

<h3 id="step-1-1-look-up-julia-com-some-image">Step 1.1: Look up julia.com/some_image</h3>

<p>rkt uses a container format called &ldquo;ACI&rdquo; today.</p>

<p>The first thing is to download the image. You find it on the internet, download
a file, okay.  This is not trivial but it&rsquo;s not what I&rsquo;m interested in
right now. Next comes the interesting (to me) part.</p>

<h3 id="step-1-2-put-the-image-in-rkt-s-local-container-store">Step 1.2: Put the image in rkt’s local container store</h3>

<p>You could imagine rkt could make your user keep those images on disk somewhere and tell you the
path to the image to run. (<code>rkt run /home/julia/my-cool-image.aci</code>). This is not what rkt does.</p>

<p>rkt instead maintains a store of all the images it knows about. Your image
needs to get into this store before it can be run.</p>

<p>Here’s all the images I have right now on my laptop. There are 2 of them.</p>

<pre><code>$ sudo rkt image list
ID			NAME					SIZE	IMPORT TIME	LAST USED
sha512-6c0b85484a1c	coreos.com/rkt/stage1-coreos:1.18.0	179MiB	1 day ago	1 day ago
sha512-7b1e1a77f0b6	coreos.com/rkt/builder:1.1.0		1.6GiB	1 day ago	1 day ago
</code></pre>

<p>Where do these images actually live on disk? In <code>/var/lib/rkt/cas/blob/sha512</code>!</p>

<pre><code> ls /var/lib/rkt/cas/blob/sha512/*
/var/lib/rkt/cas/blob/sha512/6c:
sha512-6c0b85484a1ca60df409e7944938fc6a44ccf4a2ce373d0557ea06ec56da73c9
/var/lib/rkt/cas/blob/sha512/7b:
sha512-7b1e1a77f0b693b83d87026a44d1f57b089ef392820d8b3835df292d929e8842
</code></pre>

<p>The file <code>/var/lib/rkt/cas/blob/sha512/6c/sha512-6c0b85484a1ca60df409e7944938fc6a44ccf4a2ce373d0557ea06ec56da73c9</code>
is actually a tar archive. It just contains every file that belongs in that
image! If you list the tar archive, you see a bunch of files like this. Neat!</p>

<pre><code>rootfs/usr/lib64/libc.so.6 -&gt; libc-2.21.so
rootfs/usr/lib64/libcap.so
rootfs/usr/lib64/libcap.so.2 -&gt; libcap.so.2.24
rootfs/usr/lib64/libcap.so.2.2
</code></pre>

<p>But here’s something weird: let’s compare the sizes of the images on disk, and
how much space rkt says our images take up. The /sha512-6c0b854 image is 843M,
but rkt says it’s 1.6GB! That’s almost exactly twice as much. Why? We’re going
to find out in a second.</p>

<p>Here’s me finding out that there’s a space mismatch:</p>

<pre><code>root@kiwi:/var/lib/rkt/cas/tree# du -sh /var/lib/rkt/cas/blob/sha512/*/*
90M	/var/lib/rkt/cas/blob/sha512/6c/sha512-6c0b85484a1ca60df409e7944938fc6a44ccf4a2ce373d0557ea06ec56da73c9
843M	/var/lib/rkt/cas/blob/sha512/7b/sha512-7b1e1a77f0b693b83d87026a44d1f57b089ef392820d8b3835df292d929e8842
root@kiwi:/var/lib/rkt/cas/tree# sudo rkt image list
ID			NAME					SIZE	IMPORT TIME	LAST USED
sha512-6c0b85484a1c	coreos.com/rkt/stage1-coreos:1.18.0	179MiB	1 day ago	1 day ago
sha512-7b1e1a77f0b6	coreos.com/rkt/builder:1.1.0		1.6GiB	1 day ago	1 day ag
</code></pre>

<h3 id="step-1-3-find-the-image-in-the-local-store">Step 1.3: Find the image in the local store</h3>

<p>Okay, awesome! Let’s suppose the image is already in the local store. We need
to look it up.</p>

<p>So if I’m doing <code>rkt run core.com/rkt/builder</code> I’ll find that image at
<code>/var/lib/rkt/cas/blob/sha512/7b/sha512-7b1e1a77f0b693b83d87026a44d1f57b089ef392820d8b3835df292d929e8842</code>.
But how does rkt know that that image name matches that tar file?</p>

<p>If I strace rkt, I see it reading a file called <code>/var/lib/rkt/cas/db/ql.db</code>.
What’s that? It turns out &ldquo;ql&rdquo; is an embedded SQL database written in Go. Let’s
see what’s in it! There are 3 tables (‘remote’, ‘aciinfo’, and ‘version’).
aciinfo seems to be the only really interesting one.</p>

<pre><code>$ ql  -db /var/lib/rkt/cas/db/ql.db 'select * from aciinfo'
&quot;sha512-7b1e1a77f0b693b83d87026a44d1f57b089ef392820d8b3835df292d929e8842&quot;, &quot;coreos.com/rkt/builder&quot;, 2016-10-28 23:59:50.357354868 -0400 EDT, 2016-10-28 23:59:54.158511535 -0400 EDT, false, 883696128, 864451348
&quot;sha512-6c0b85484a1ca60df409e7944938fc6a44ccf4a2ce373d0557ea06ec56da73c9&quot;, &quot;coreos.com/rkt/stage1-coreos&quot;, 2016-10-28 23:56:30.485120722 -0400 EDT, 2016-10-28 23:56:30.950583566 -0400 EDT, false, 93723136, 93603074
</code></pre>

<p>Okay, so we can look up the image by name in the SQL database and find out where it’s supposed to be on disk. Great! What now?</p>

<h3 id="step-1-4-copy-everything-from-the-image-store-to-the-tree-store">Step 1.4: copy everything from the &ldquo;image store&rdquo; to the &ldquo;tree store&rdquo;</h3>

<p>So, you might think that we use the image store to run containers (from /var/lib/rkt/cas/blob). This is how Docker works &ndash; it just stores a bunch of images on disk and uses them directly to run containers. rkt has an EXTRA STEP, though. So before you can run your container, it</p>

<p>1) finds all your container’s dependencies
2) unzips every dependency into a single directory all on top of each other
3) calls that the &ldquo;tree store&rdquo;</p>

<p>If you think this takes extra disk space, you are right! When you use rkt to run a container you get 2 copies of every file in that container. I was confused about this so I asked on the mailing list why it is (which delayed me making progress on this post for several). <a href="https://groups.google.com/forum/?pli=1#!topic/rkt-dev/bhGeR3pUfPY">Here is the question I asked</a></p>

<p>I’m going to copy the relevant part of the reply here because it was VERY HELPFUL.</p>

<blockquote>
<p>One of the key differences between the ACI and Docker formats is that while Docker&rsquo;s layers are essentially a linked list, ACI dependencies instead form a directed acyclic graph, with a separate whitelist system. This means that to create a root filesystem from a Docker image and its parent layers, you can simply layer them on top of each other while respecting the AUFS-style whiteout files; whereas the process of rendering an ACI as a root filesystem is rather more complicated [1], as you need to traverse a full graph [2], and can have cases like the same image appearing multiple times in the graph but with a different whitelist affecting which parts of it should be used [3]. To compensate for this additional complexity, we &ldquo;pre-render&rdquo; the root filesystem that an ACI represents into the treestore [4], and then use overlayfs on top of this at runtime.</p>
</blockquote>

<p>So basically this is because of a fundamental difference between the ACI format and the Docker image format. But the new OCI format is more like the Docker format! And they’re rearchitecting how they do all their container storage on disk. So this might all be completely different in the future. Let’s move along.</p>

<h1 id="part-2-prepare-to-runnnn">Part 2: PREPARE TO RUNNNN</h1>

<p>Before we run, we have to PREPARE to run.</p>

<h3 id="step-2-1-create-a-pod">Step 2.1: Create a pod</h3>

<p>So when you run a rkt container, you’re actually running a thing called a &ldquo;pod&rdquo;. I am still somewhat confused about what running a pod entails exactly but I know that</p>

<p>1) you get a pod ID like 9ec8ec92-f04d-4194-956f-2aa1fe94389c
2) pods do not get automatically deleted when your program exits (they need to be garbage collected)
3) you can run &ldquo;rkt prepare&rdquo; to prepare a pod to run and then <code>rkt run-prepared</code> to run an already set-up pod</p>

<h3 id="step-2-2-mount-the-pod-s-filesystems">Step 2.2: mount the pod’s filesystems</h3>

<p>To run a program, the pod needs files! The files that the pod is going to run are in the &ldquo;tree store&rdquo;. Here’s a system call from rkt setting up the pod’s filesystems:</p>

<pre><code>32034 mount(&quot;overlay&quot;,
&quot;/var/lib/rkt/pods/run/9ec8ec92-f04d-4194-956f-2aa1fe94389c/stage1/rootfs&quot;,
&quot;overlay&quot;, 0,
&quot;lowerdir=/var/lib/rkt/cas/tree/deps-sha512-7d429fe0c72eb12b91726bde7ff2b730b4b72c1c380a4ea5d09ff162b086cb49/rootfs,upperdir=/var/lib/rkt/pods/run/9ec8ec92-f04d-4194-956f-2aa1fe94389c/overlay/deps-sha512-7d429fe0c72eb12b91726bde7ff2b730b4b72c1c380a4ea5d09ff162b086cb49/upper,workdir=/var/lib/rkt/pods/run/9ec8ec92-f04d-4194-956f-2aa1fe94389c/overlay/deps-sha512-7d429fe0c72eb12b91726bde7ff2b730b4b72c1c380a4ea5d09ff162b086cb49/work&quot;)
= 0b12b91726bde7ff2b730b4b72c1c380a4ea5d09ff162b086cb49
</code></pre>

<p>Goodness. This basically says &ldquo;take <code>/var/lib/rkt/cas/tree/deps-sha512-7d429fe0c72e...</code> and <code>/var/lib/rkt/pods/run/9ec8ec92-f04d-4194-956f-2aa1fe94389c/overlay/deps-sha512-7d429fe0c72eb12b91726bde7ff2b730b4b72c1c380a4ea5d09ff162b086cb49/upper</code> and put them together to make <code>/var/lib/rkt/pods/run/9ec8ec9.../stage1/rootfs</code>&rdquo;.</p>

<p>This is called an &ldquo;overlay filesystem&rdquo; and it is a big part of how containers work. Basically if you want to run 3 programs on the same computer with the same base container, you can! And they can share files on disk! But that doesn’t mean they share files with each other &ndash; if one program edits a file from the base container, the other programs won’t see the changes. Instead they all get their own filesystems, which use copy-on-write.</p>

<h1 id="part-3-run">Part 3: RUN!!!!!!!!!!</h1>

<p>The last thing we get to do is RUN THE CONTAINER. We’re going to go through a
bunch of system calls now! Here’s how I ran <code>rkt run</code>, with some commentary
about why I picked that option. Basically I picked options that would run my
container in the simplest way possible. Simplest does not mean best &ndash; the simplest way
includes turning off all security features :)</p>

<pre><code>rkt run 
   coreos.com/rkt/builder
  # security features are complicated! turn them all off
  --insecure-options=all
  # no network namespaces, just do the most boring possible networking
  --net=host
  # use the &quot;fly&quot; stage1 -- this will just run my container using a chroot
  # (network namespaces don't even work with this anyway, the --net=host is kinda redundant)
  --stage1-name=coreos.com/rkt/stage1-fly:1
  # set up a couple of volumes that this particular container wants
  --volume src-dir,kind=host,source=(pwd)
  --volume build-dir,kind=host,source=(pwd)/build
</code></pre>

<p>Okay, what happens when we do this? We&rsquo;ve already set up our pod (in the PREPARE step). Here&rsquo;s the first interesting thing I saw.</p>

<pre><code>/var/lib/rkt/pods/run/10a558fc-f917-443a-ad23-b54a7c5ce95d/stage1/rootfs/run
</code></pre>

<p>It is running our program! It then goes and does a bunch of boring stuff where
it sets up /proc or whatever. This is pretty annoying to read because this
program is a Go program so there are a lot of weird Go runtime system calls
because it runs one thread per core or something.</p>

<p>Also it reads the pod manifest and figures out what its job is (what program is
it supposed to run).</p>

<p>This container&rsquo;s job is to run a file called <code>/scripts/build.sh</code>. It finally does
it! Here&rsquo;s what that looks like:</p>

<pre><code>30297 chroot(&quot;stage1/rootfs/opt/stage2/builder/rootfs&quot;) = 0
30297 chdir(&quot;/opt/rkt&quot;)                 = 0
30297 setresgid(0, 0, 0)                = 0
30297 setresuid(0, 0, 0)                = 0
30297 fcntl(4, F_SETFD, 0)              = 0
30297 execve(&quot;/bin/bash&quot;, [&quot;/bin/bash&quot;, &quot;/scripts/build.sh&quot;], [/* 5 vars */] &lt;unfinished ...&gt;
</code></pre>

<p>We did it! We ran a container!</p>

<h3 id="what-is-this-stage1-business-julia">what is this &ldquo;stage1&rdquo; business, julia?</h3>

<p>Yeah, sorry, this is a weird rkt thing. BASICALLY there is a set of programs
called &ldquo;stage1&rdquo; which get included in your filesystem. Their job is to take
your &ldquo;container manifest&rdquo;  (which says what program to run) and the rkt command
line arguments (like which ports to map to which other ports) and make it all
happen for you. So they&rsquo;re basically responsible for setting up the actual
container.</p>

<p>As far as I understand there are basically only 2 interesting ones: the regular
one (which uses systemd) and the lightweight one (&ldquo;fly&rdquo;). I picked the
lightweight one here because the other one has way more system calls and it&rsquo;s
more complicated to understand.</p>

<h3 id="step-a-lot-of-security-checks">Step ???: A lot of security checks</h3>

<p>One thing I’ve intentionally left out here is &ndash; rkt does a ton of security checks when you run a container. They’re called &ldquo;image&rdquo;, &ldquo;tls&rdquo;, &ldquo;ondisk&rdquo;, &ldquo;http&rdquo;, &ldquo;pubkey&rdquo;, &ldquo;capabilities&rdquo;, &ldquo;paths&rdquo;, and &ldquo;seccomp&rdquo;. You might have noticed that I ran with <code>--insecure-options=all</code>. This is not what I do in real life, but it is a lot to talk about and this is already getting to be 2000 words.</p>

<p>Some of them are during fetch (which you can separate out and do before running the container) and some of them are during run. So it might be reasonable to ignore all the <code>fetch</code> security checks if you already did them all when fetching. Who knows. I’m not going to give you security recommendations, you should not listen to me.</p>

<h3 id="understanding-the-systems-you-are-using-is-cool">Understanding the systems you are using is cool</h3>

<p>Someone on twitter asked me &ldquo;julia, why are you asking all these questions,
this is not the level of abstraction you should work at, you need to ship
code!&rdquo;</p>

<p>And this is sort of true! Everyone should not need to know all the details of
how everything they use works. That would take too much time. Imagine if every
Linux user needed to read Linux kernel code to do their job! Eep.</p>

<p>HOWEVER. Right now it is my job to work on making sure containers will work, so
that other people do not have to worry about it! This means that I have to (get
to?) worry about some of the weird stuff my container software is doing.</p>

<p>If I know rkt&rsquo;s storage model, then I can make guesses at exactly how much disk
space rkt is going to use in production, then I can plan to give my machines an
appropriate amount of storage, and then nobody will run out of disk space!
Running out of disk space is THE WORST.</p>

<p>This is why I appreciate documents like Kelsey Hightower&rsquo;s <a href="https://github.com/kelseyhightower/kubernetes-the-hard-way">Kubernetes the Hard Way</a> &ndash; when you
work with complex systems, a lot of the time <strong>someone</strong> needs to understand
how they work, so they can plan to operate the system correctly.</p>

<p>Right now I get to be that someone, for some things. Yay!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What even is a container: namespaces and cgroups]]></title>
    <link href="https://jvns.ca/blog/2016/10/10/what-even-is-a-container/"/>
    <updated>2016-10-10T22:44:13+00:00</updated>
    <id>https://jvns.ca/blog/2016/10/10/what-even-is-a-container/</id>
    <content type="html"><![CDATA[

<p>The first time I heard about containers it was like &ndash; what? what&rsquo;s that?</p>

<p>Is a container a process? What&rsquo;s Docker? Are containers Docker? Help!</p>

<p>The word &ldquo;container&rdquo; doesn&rsquo;t mean anything super precise. Basically there are a few new  Linux kernel features (&ldquo;namespaces&rdquo; and &ldquo;cgroups&rdquo;) that let you isolate processes from each other. When you use those features, you call it &ldquo;containers&rdquo;.</p>

<p>Basically these features let you pretend you have something like a virtual machine, except it&rsquo;s not a virtual machine at all, it&rsquo;s just processes running in the same Linux kernel. Let&rsquo;s dive in!</p>

<h3 id="namespaces">namespaces</h3>

<p>Okay, so let&rsquo;s say we wanted to have something like a virtual machine. One feature you
might want is &ndash; my processes should be separated from the other processes on the
computer, right?</p>

<p>One feature Linux provides here is <strong>namespaces</strong>. There are a bunch of different kinds:</p>

<ul>
<li>in a <strong>pid</strong> namespace you become PID 1 and then your children are other processes. All the other programs are gone</li>
<li>in a <strong>networking namespace</strong> you can run programs on any port you want without it conflicting with what&rsquo;s already running</li>
<li>in a <strong>mount namespace</strong> you can mount and unmount filesystems without it affecting the host filesystem. So you can have a totally different set of devices mounted (usually less)</li>
</ul>

<p>It turns out that making namespaces is totally easy! You can just run a program called <code>unshare</code> (named after the system call of the same name)</p>

<p>Let&rsquo;s make a new PID namespace and run bash in it!</p>

<pre><code>$ sudo unshare --fork --pid --mount-proc bash
</code></pre>

<p>What&rsquo;s going on?</p>

<pre><code>root@kiwi:~# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0  28372  4148 pts/6    S    23:01   0:00 bash
root         2  0.0  0.0  44432  3836 pts/6    R+   23:01   0:00 ps aux
</code></pre>

<p>Wow, we&rsquo;re in a whole new world! There are only 2 processes running &ndash; bash and ps. Cool, that was easy!</p>

<p>It&rsquo;s worth noting that if I look from my regular PID namespaces, I can see the processes in the new PID namespace:</p>

<pre><code>root     14121  0.0  0.0  33264  4044 pts/6    S+   23:09   0:00 htop
</code></pre>

<p>This process 14121 (regular namespace) is process 3 in my new PID namespace. So they&rsquo;re two views on the same thing, but one is a lot more restricted.</p>

<h3 id="entering-the-namespace-of-another-program">entering the namespace of another program</h3>

<p>Also you can enter the namespace of another running program! You do this with a command called <code>nsenter</code>. I think this is how <code>docker exec</code> works? Maybe?</p>

<h3 id="cgroups-resource-limits">cgroups: resource limits</h3>

<p>Okay, so we&rsquo;ve made a new magical world with new processes and sockets that is separate from our old world. Cool!</p>

<p>What if I want to limit how much memory or CPU one of my programs is using? WE&rsquo;RE IN LUCK. In 2007 some people developed <a href="https://en.wikipedia.org/wiki/Cgroups">cgroups</a> just for us. These are like when you <code>nice</code> a process but with a bunch more features.</p>

<p>Let&rsquo;s make a cgroup! We&rsquo;ll make one that just limits memory</p>

<pre><code>$ sudo cgcreate -a bork -g memory:mycoolgrou
</code></pre>

<p>Let&rsquo;s see what&rsquo;s in it!</p>

<pre><code>$ ls -l /sys/fs/cgroup/memory/mycoolgroup/
-rw-r--r-- 1 bork root 0 Okt 10 23:16 memory.kmem.limit_in_bytes
-rw-r--r-- 1 bork root 0 Okt 10 23:14 memory.kmem.max_usage_in_bytes
</code></pre>

<p>ooh, max usage in bytes! Okay, let&rsquo;s try that! 10 megabytes should be enough for anyone!
10 megabytes should be enough for anyone!</p>

<pre><code>$ sudo echo 10000000 &gt;  /sys/fs/cgroup/memory/mycoolgroup/memory.kmem.limit_in_bytes
</code></pre>

<p>Awesome, let&rsquo;s try using my cgroup!</p>

<pre><code>$ sudo cgexec  -g memory:mycoolgroup bash
</code></pre>

<p>I ran a bunch of commands. they worked fine. Then I tried compiling a Rust program :) :) :)</p>

<pre><code>$ root@kiwi:~/work/ruby-stacktrace# cargo build
error: Could not execute process `rustc -vV` (never executed)

Caused by:
  Cannot allocate memory (os error 12)
</code></pre>

<p>Fantastic! We have successfully limited our program&rsquo;s memory!</p>

<h3 id="seccomp-bpf">seccomp-bpf</h3>

<p>Okay, one last feature! If you&rsquo;re isolating your processes, you might in addition to restricting their memory and CPU usage, want to restrict what system calls they can run! Like, &ldquo;no network access for you!&rdquo;.  That might help with security! We like security.</p>

<p>This brings us to <a href="https://en.wikipedia.org/wiki/Seccomp">seccomp-bpf</a>, a Linux kernel feature that lets you filter which system calls your process can run.</p>

<h3 id="what-are-containers">what are containers?</h3>

<p>Okay, now that you&rsquo;ve seen these two features you might think &ldquo;wow, yeah, I could build a bunch of scripts around all these features and have something really cool!&rdquo; It would be really lightweight and my processes would be isolated from each other, and, wow!</p>

<p>Some people thought that in the past too! They built a thing called &ldquo;Docker containers&rdquo; that uses these features :). That&rsquo;s all Docker is! Of course Docker has a lot of features these days, but a lot of it is built on these basic Linux kernel primitives.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A list of Linux container software]]></title>
    <link href="https://jvns.ca/blog/2016/10/02/a-list-of-container-software/"/>
    <updated>2016-10-02T20:02:25+00:00</updated>
    <id>https://jvns.ca/blog/2016/10/02/a-list-of-container-software/</id>
    <content type="html"><![CDATA[<p>I have been confused about the plethora of container software in the world. This is a
list, mostly to remind myself that there is a lot of software and so it is not surprising
that I do not understand what it all is yet.</p>

<p>I&rsquo;ve tried to restrict this to just &ldquo;software that you might reasonably want to
use/consider/understand when running containers in production&rdquo;. My rough heuristic for
this is just &ldquo;software someone has told me about more than once, and is not experimental&rdquo;.
Obviously some of these things are more important than others.</p>

<p>Having written this down, I feel a bit better &ndash; there are only 17 pieces of software on
this list, from 6 different organizations. That&rsquo;s actually less than I felt like it was
and I kinda sorta know what all of these things do.</p>

<p>The major organizations writing open source software to help people run containers on
Linux seem to be (alphabetically): Canonical, CoreOS, Docker, Google, HashiCorp, Mesosphere, Red Hat, and OCI (cross-company foundation).</p>

<p>I&rsquo;ve tried to summarize each one in 3 words or less which is hard because a lot of this
software has a lot of different jobs.</p>

<ul>
<li>docker stuff

<ul>
<li><a href="https://www.docker.com/">docker</a></li>
<li><a href="https://www.containerd.tools">containerd</a> (process supervisor)</li>
<li><a href="https://docs.docker.com/swarm/">docker swarm</a> (orchestration)</li>
</ul></li>
<li>Kubernetes stuff

<ul>
<li><a href="http://kubernetes.io/">kubernetes</a> (orchestration, has many components)</li>
</ul></li>
<li>Mesosphere stuff

<ul>
<li><a href="http://mesos.apache.org/">Mesos</a> (orchestration)</li>
</ul></li>
<li>CoreOS stuff

<ul>
<li><a href="https://coreos.com/why/">CoreOS</a> (linux distribution)</li>
<li><a href="https://coreos.com/rkt">rkt</a>  (runs containers)</li>
<li><a href="(https://coreos.com/flannel/docs/latest/)">flannel</a> (network overlay)</li>
<li><a href="https://coreos.com/etcd/">etcd</a> (key-value store)</li>
</ul></li>
<li>HashiCorp stuff

<ul>
<li><a href="https://www.consul.io/">consul</a> (key-value store, service discovery)</li>
<li><a href="https://www.packer.io/intro/">packer</a> (creates containers)</li>
<li><a href="https://www.vaultproject.io/">vault</a> (secrets management)</li>
<li><a href="https://www.nomadproject.io/">nomad</a> (orchestration)</li>
</ul></li>
<li>OCI (open container initiative) stuff

<ul>
<li><a href="http://runc.io/">runC</a> (runs containers)</li>
<li><a href="https://github.com/opencontainers/runc/tree/master/libcontainer">libcontainer</a> (donated by Docker, powers runC)</li>
</ul></li>
<li>systemd-nspawn (<a href="https://www.freedesktop.org/software/systemd/man/systemd-nspawn.html">man page</a>) (starts containers)</li>
<li><a href="https://github.com/Yelp/dumb-init">dumb-init</a> (init process)</li>
<li><a href="https://linuxcontainers.org/">LXC</a> (runs containers, from Canonical)</li>
</ul>

<p>There are also a bunch of container registries you can pay for, like <a href="https://quay.io/">quay (from CoreOS)</a>, <a href="https://cloud.google.com/container-registry/">google&rsquo;s one</a>, <a href="https://docs.docker.com/docker-trusted-registry/">docker trusted registry</a>, etc.</p>

<p>I&rsquo;ve probably missed at least one important organization / piece of software here. As
usual you can tell me about it <a href="https://twitter.com/b0rk">on twitter</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[&#34;I just want to run a container!&#34;]]></title>
    <link href="https://jvns.ca/blog/2016/10/02/i-just-want-to-run-a-container/"/>
    <updated>2016-10-02T10:43:30+00:00</updated>
    <id>https://jvns.ca/blog/2016/10/02/i-just-want-to-run-a-container/</id>
    <content type="html"><![CDATA[

<p>I wrote <a href="http://jvns.ca/blog/2016/09/15/whats-up-with-containers-docker-and-rkt/">&ldquo;what&rsquo;s up with containers: Docker and rkt&rdquo;</a>
a while ago. Since then I have learned a few new things about containers! We&rsquo;re going to
talk about running containers in production, not on your laptop for development, since I&rsquo;m
trying to understand how that works in September 2016. It&rsquo;s worth noting that all this
stuff is moving pretty fast right now.</p>

<p>The concerns when you run containers in production are pretty different from running it on a laptop &ndash; I <a href="http://jvns.ca/blog/2015/11/09/docker-is-amazing/">very happily</a> use Docker on my laptop and I have no real concerns about it because I don&rsquo;t care much if processes on my laptop crash like 0.5% of the time, and I haven&rsquo;t seen any problems.</p>

<p>Here are the things I&rsquo;ve learned so far. I learned many of these things with
<a href="https://twitter.com/grepory">@grepory</a> who is the best. Basically I want to talk about what some of the things you need to think about are
if you want to run containers, and what is involved in &ldquo;just running a container&rdquo; :)</p>

<p>At the end I&rsquo;m going to come back to a short discussion of Docker&rsquo;s current architecture. (tl;dr:
<a href="https://twitter.com/jpetazzo">@jpetazzo</a> wrote a <a href="https://gist.github.com/jpetazzo/f1beba1dfd4c38e8daf2ebf2dcf3cdeb">really awesome gist</a>)</p>

<h3 id="docker-is-too-complicated-i-just-want-to-run-a-container">Docker is too complicated! I just want to run a container</h3>

<p>So, I saw this image online! (comes from <a href="https://medium.com/@adriaandejonge/moving-from-docker-to-rkt-310dc9aec938#.mmmi6m9ql">this article</a>)
<img src="/images/docker-rkt.png"></p>

<p>And I thought &ldquo;that rkt diagram looks way easier to operate in production! That&rsquo;s what I
want!&rdquo;</p>

<p>Okay, sure! No problem. I can use <code>runC</code>! Go to <a href="http://runc.io/">runc.io</a>, follow the
direction, make a <code>config.json</code> file, extract my container into a tarball, and now I can
run my container with a single command. Awesome.</p>

<h3 id="actually-i-want-to-run-50-containers-on-the-same-machine">Actually I want to run 50 containers on the same machine.</h3>

<p>Oh, okay, that&rsquo;s pretty different. So &ndash; let&rsquo;s say all my 50 containers share a bunch of
files (shared libraries like libc, Ruby gems, a base operating system, etc.). It would be
nice if I could load all those files into memory just once, instead of 3 times.</p>

<p>If I did this I could save disk space on my machine (by just storing the files once), but
more importantly, I could save memory!</p>

<p>If I&rsquo;m running 50 containers I don&rsquo;t want to have 50 copies of all my shared libraries in
memory. That&rsquo;s why we invented dynamic linking!</p>

<p>If you&rsquo;re running just 2-3 containers, maybe you don&rsquo;t care about a little bit of copying.
That&rsquo;s for you to decide!</p>

<p>It turns out that the way Docker solves this is with &ldquo;overlay filesystems&rdquo; or
&ldquo;graphdrivers&rdquo;. (why are they called graphdrivers? Maybe because different layers depend on each other like in a directed graph?) These let you stack
filesystems &ndash; you start with a base filesystem (like Ubuntu 14.04) and then you can start
adding more files on top of it one step at a time.</p>

<p>Filesystem overlays need some Linux kernel support to work &ndash; you need to use a filesystem that supports them. <a href="https://blog.jessfraz.com/post/the-brutally-honest-guide-to-docker-graphdrivers/">The Brutally Honest Guide to Docker Graphdrivers</a> by the fantastic Jessie Frazelle has a quick overview. overlayfs seems to be the most normal option.</p>

<p>At this point, I was running Ubuntu 14.04. 14.04 runs a 3.13 Linux kernel! But to use overlayfs, you need a 3.18 kernel! So you need to upgrade your kernel. That&rsquo;s fine.</p>

<p>Back to <code>runC</code>. <code>runC</code> <a href="https://github.com/opencontainers/runc/issues/1040">does not support overlay filesystems</a>. This is an intentional design choice &ndash; it lets runC run on older kernels, and lets you separate out the concerns. But it&rsquo;s not super obvious right now how to use runC with overlay filesystems. So what do I do?</p>

<h3 id="i-m-going-to-use-rkt-to-get-overlay-filesystem-support">I&rsquo;m going to use rkt to get overlay filesystem support</h3>

<p>So! I&rsquo;ve decided I want overlay filesystem support, and gotten a Linux kernel newer than
3.18. Awesome. Let&rsquo;s try rkt, like in that diagram! It lives at
<a href="https://coreos.com/rkt/">coreos.com/rkt/</a></p>

<p>If you download <code>rkt</code> and run <code>rkt run docker://my-docker-registry/container</code>, This
totally works. Two small things I learned:</p>

<p><strong><code>--net=host</code></strong> will let you run in the host network namespace</p>

<p>Network namespaces are one of the most important things in container land. But if you want to run containers using as few new things as possible, you can start out by just running your containers as normal programs that run on normal ports, like any other program on your computer. Cool</p>

<p><strong><code>--exec=/my/cool/program</code></strong> lets you set which command you want rkt to execute inside the image</p>

<p><strong>systemd</strong>: rkt will run a program called <code>systemd-nspawn</code> as the init (PID 1) process inside your container. This is because <a href="https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html">it can be bad to run an arbitrary process as PID 1</a> &ndash; your process isn&rsquo;t expecting it and will might react badly. It also run some systemd-journal process? I don&rsquo;t know what that&rsquo;s for yet.</p>

<p>The systemd journal process might act as a syslog for your container, so that programs sending logs through syslog end up actually sending them somewhere.</p>

<p>There is quite a lot more to know about rkt but I don&rsquo;t know most of it yet.</p>

<h3 id="i-d-like-to-trust-that-the-code-i-m-running-is-actually-my-code">I&rsquo;d like to trust that the code I&rsquo;m running is actually my code</h3>

<p>So, security is important. Let&rsquo;s say I have a container registry. I&rsquo;d like to make sure
that the code I&rsquo;m running from that registry is actually trusted code that I built.</p>

<p>Docker lets you sign images to verify where they came from. rkt lets you run Docker
images. rkt does not let you check signatures from Docker images though! This is bad.</p>

<p>You can fix this by setting up your own rkt registry. Or maybe other things! I&rsquo;m going to
leave that here. At this point you probably have to stop using Docker containers though and convert them to a different format.</p>

<h3 id="supervising-my-containers-and-let-s-talk-about-docker-again">Supervising my containers (and let&rsquo;s talk about Docker again)</h3>

<p>So, I have this Cool Container System, and I can run containers with overlayfs and I can
trust the code I&rsquo;m running. What now?</p>

<p>Let&rsquo;s go back to Docker for a bit. So far I&rsquo;ve been a bit dismissive about Docker, and I&rsquo;d
like to look at its current direction a little more seriously. Jérôme Petazzoni wrote an
extremely informative and helpful discussion about how Docker got to its architecture
today in <a href="https://gist.github.com/jpetazzo/f1beba1dfd4c38e8daf2ebf2dcf3cdeb">this gist</a>. He says (which I think is super true) that Docker&rsquo;s approach to date has done a huge amount to drive container adoption and let us try out different approaches today.</p>

<p>The end of that gist is a really good starting point for talking about how &ldquo;start new containers&rdquo; should work.</p>

<p>Jérôme very correctly says that if you&rsquo;re going to run containers, you need a way to
tell boxes which containers to run, and supervise and restart containers when they die. You could supervise them with daemontools,
supervisord, upstart, or systemd, or something else!</p>

<p>&ldquo;Tell boxes which containers to run&rdquo; is another nontrivial problem and I&rsquo;m not going to
talk about it at all here. So, back to supervision.</p>

<p>Let&rsquo;s say you use systemd. Then that&rsquo;ll look like (from the diagram I posted at the top):</p>

<pre><code>- systemd -+- rkt -+- process of container X
           |       \- other process of container X
           +- rkt --- process of container Y
           \- rkt --- process of container Z
</code></pre>

<p>I don&rsquo;t know anything about systemd, but it&rsquo;s pretty straightforward to tell daemontools
&ldquo;hey, here&rsquo;s a new process to start running, it&rsquo;s going to run a container&rdquo;. Then
daemontools will restart that container process if it crashes. So this is basically fine.</p>

<p>My understanding of the problem with Docker in production historically is that &ndash; the
process that is responsible for this core functionality of process supervision was the
Docker engine, but it also had a lot of other features that you don&rsquo;t necessarily want
running in production.</p>

<p>The way Docker seems to be going in the future is something like: (this diagram is from jpetazzo&rsquo;s gist above)</p>

<pre><code>- init - containerd -+- shim for container X -+- process of container X
         |                        \- other process of container X
                     +- shim for container Y --- process of container Y
                     \- shim for container Z --- process of container Z
</code></pre>

<p>where <a href="https://containerd.tools/">containerd</a> is a separate tool, and the Docker engine
talks to containerd but isn&rsquo;t as heavily coupled to it. Right now containerd&rsquo;s website
says it&rsquo;s alpha software, but they also say on their website that it’s used in current versions of Docker, so it’s not totally obvious what the state is right now.</p>

<h3 id="the-oci-standard">the OCI standard</h3>

<p>We talked about how <code>runC</code> can run containers just fine, but cannot do overlay filesystems or fetch + validate containers from a registry. I would be remiss if I didn&rsquo;t mention the OCID project that @grepory told me about last week, which aims to do those as separate components instead of in an integrated system like Docker.</p>

<p>Here&rsquo;s the article: <a href="http://thenewstack.io/oci-building-way-kubernetes-run-containers-without-docker/">Red Hat, Google Engineers Work on a Way for Kubernetes to Run Containers Without Docker </a>.</p>

<p>Today there&rsquo;s <a href="https://github.com/projectatomic/skopeo">skopeo</a> which lets you fetch and validate images from Docker registries</p>

<h3 id="what-we-learned">what we learned</h3>

<p>here&rsquo;s the tl;dr:</p>

<ul>
<li>you can run Docker containers without Docker</li>
<li>runC can run containers&hellip; but it doesn&rsquo;t have overlayfs</li>
<li>but overlay filesystems are important!</li>
<li>rkt has overlay filesystem support.</li>
<li>you need to start &amp; supervise the containers! You can use any regular process supervisor to do that.</li>
<li>also you need to tell your computers which containers to run</li>
<li>software around the OCI standard is evolving but it&rsquo;s not there yet</li>
</ul>

<p>As far as I can tell running containers without using Docker or Kubernetes or anything is
totally possible today, but no matter what tools you use it’s definitely not as simple as
&ldquo;just run a container&rdquo;. Either way going through all these steps helps me understand what
the actual components of running a container are and what all these different pieces of
software are trying to do.</p>

<p>This landscape is pretty confusing but I think it’s not impossible to understand! There
are only a finite number of different pieces of software to figure out the role of :)</p>

<p>If you want to see more about running containers from scratch, see <a href="https://www.youtube.com/watch?v=sK5i-N34im8&amp;feature=youtu.be">Cgroups, namespaces, and beyond: what are containers made from?</a> by jpetazzo. There’s a live demo of how to run a container with 0 tools (no docker, no rkt, no runC) <a href="https://www.youtube.com/watch?v=sK5i-N34im8&amp;feature=youtu.be&amp;t=41m11s">at this point in the video</a> which is super super interesting.</p>

<p><small> Thanks to Jérôme Petazzoni for answering many questions and to Kamal Marhubi for reading this.</small></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some questions about Docker and rkt]]></title>
    <link href="https://jvns.ca/blog/2016/09/15/whats-up-with-containers-docker-and-rkt/"/>
    <updated>2016-09-15T23:52:04+00:00</updated>
    <id>https://jvns.ca/blog/2016/09/15/whats-up-with-containers-docker-and-rkt/</id>
    <content type="html"><![CDATA[

<p>Hello! I have been thinking about containers at work. I&rsquo;m going to talk about
running containers in production! I&rsquo;ve talked before about how
<a href="http://jvns.ca/blog/2015/11/09/docker-is-amazing/">using Docker for development is great</a>,
but that&rsquo;s not what this post is about. Using docker in development seems really great and fine and I have no problems with it.</p>

<p>However I have VERY MANY QUESTIONS about running Docker in production. As a
preface &ndash; I have never run containers in production. You should not take
advice from me. So far reading about containers mostly feels like <a href="https://circleci.com/blog/its-the-future/">this hilarious article</a>.</p>

<p>So: your setting is, you have a server, and you want to run programs on that
server. In containers, maybe! Should you use Docker? I have no idea! Let&rsquo;s
talk about what we do know, though.</p>

<p>If you want to know what containers are, you could read <a href="https://medium.com/@gtrevorjay/you-could-have-invented-container-runtimes-an-explanatory-fantasy-764c5b389bd3">You Could Have Invented Container Runtimes: An Explanatory Fantasy</a></p>

<h3 id="reasons-to-use-containers">reasons to use containers</h3>

<p><strong>packaging</strong>. Let&rsquo;s imagine you want to run your application on a computer. Your application depends on some weird JSON library being installed.</p>

<p>Installing stuff on computers so you can run your program on them really
sucks. It&rsquo;s easy to get wrong! It&rsquo;s scary when you make changes! Even if you
use Puppet or Chef or something to install the stuff on the computers, it
sucks.</p>

<p>Containers are nice, because you can install all the stuff your program needs to run in the container <strong>inside the container</strong>.</p>

<p>packaging is a huge deal and it is probably the thing that is most interesting to me about containers right now</p>

<p><strong>scheduling</strong>. $$$. Computers are expensive. If you have custom magical computers that are all set up differently, it&rsquo;s hard to move your programs from running on Computer 1 to running on Computer 2. If you use containers, you can make your computers all the same! Then you can more easily pack your programs onto computers in a more reasonable way. Systems like Kubernetes do this automagically but we are not going to talk about Kubernetes.</p>

<p><strong>better developer environment</strong>. If you can make your application run in a container, then maybe you can also develop it on your laptop in the same container? Maybe? I don&rsquo;t really know much about this.</p>

<p><strong>security</strong>. You can use seccomp-bpf or something to restrict which system calls your program runs? <a href="https://sandstorm.io/">sandstorm</a> does stuff like this. I don&rsquo;t really know.</p>

<p>There are probably more reasons that I&rsquo;ve forgotten right now.</p>

<h3 id="ok-so-what-s-up-with-the-docker-daemon">ok so what&rsquo;s up with the Docker daemon</h3>

<p>Docker has a daemon. Here is an architecture diagram that I shamelessly stole from <a href="https://medium.com/@adriaandejonge/moving-from-docker-to-rkt-310dc9aec938#.mmmi6m9ql">this article</a></p>

<div align="center"><img src="/images/docker-rkt.png"></div>

<p>Usually I run programs on my computers. With Docker, you have to run a magical &ldquo;docker daemon&rdquo; that handles all my containers. Why? I don&rsquo;t know! I don&rsquo;t understand what the Docker daemon is for. With rkt, you just run a process.</p>

<p>People have been telling me stories that sometimes if you do the Wrong
Thing and the Docker daemon has a bug, then the daemon can get deadlocked and
then you have to kill it and all your containers die. I assume they work
pretty hard on fixing these bugs, but I don&rsquo;t <strong>want</strong> to have to trust that
the Docker daemon has no bugs that will affect me. All software has bugs!</p>

<p>If you treat your container more like a process, then you can just run it,
supervise it with supervisord or upstart or whatever your favorite way to
supervise a process is. I know what a process is! I understand processes, kind
of. Also I already use supervisord so I believe in that.</p>

<p>So that kind of makes me want to run rkt, even though it is a Newer Thing.</p>

<h3 id="pid-1">PID 1</h3>

<p>My coworker told me a very surprising thing about containers. If you run just one process in a container, then it apparently gets PID 1? PID 1 is a pretty exciting process. Usually on your computer, <code>init</code> gets PID 1. In particular, if another container process gets orphaned, then it suddenly magically becomes a child of PID 1.</p>

<p>So this is kind of weird, right? You don&rsquo;t want your process to get random zombie processes as children. Like that might be fine, but it violates a lot of normal Unix assumptions about what normally happens to normal processes.</p>

<p>I think &ldquo;violates a lot of normal Unix assumptions about what normally happens to normal processes&rdquo; is basically the whole story about containers.</p>

<p>Yelp made a solution to this called <a href="https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html">dumb-init</a>. It&rsquo;s kind of interesting.</p>

<h3 id="networking">networking</h3>

<p>I wrote a pretty bad blog post about container networking a while back. It can
be really complicated! There are these &ldquo;network namespaces&rdquo; that I don&rsquo;t
really understand, and you need to do port forwarding, and why?</p>

<p>Do you really need to use this complicated container networking stuff? I kind
of just want to run container processes and run them on normal ports in my
normal network namespace and leave it at that. Is that wrong?</p>

<h3 id="secrets">secrets</h3>

<p>Often applications need to have passwords and things! Like to databases! How do you get the passwords into your container? This is a pretty big problem that I&rsquo;m not going to go into now but I wanted to ask the question. (I know there are things like vault by hashicorp. Is using that a good idea? I don&rsquo;t know!)</p>

<h3 id="creating-container-images">creating container images</h3>

<p>To run containers, you need to create container images! There seem to be two main formats: Docker&rsquo;s format and rkt&rsquo;s format. I know nothing about either of them.</p>

<p>One nice thing is that rkt can run Docker containers images. So you could use Docker&rsquo;s tools to make a container but then run it without using Docker.</p>

<p>There are at least 2 ways to make a Docker image: using a Dockerfile and <a href="https://www.packer.io/">packer</a>. Packer lets you provision a container with Puppet or Chef! That&rsquo;s kind of useful.</p>

<h3 id="so-many-questions">so many questions</h3>

<p>From the few (maybe 5?) people I&rsquo;ve talked to about containers so far, the overall consensus seems to be that they&rsquo;re a pretty useful thing, despite all the hype, but that there are a lot of sharp edges and unexpected things that you&rsquo;ll have to make your way through.</p>

<p>Good thing we can all learn on the internet together.</p>
]]></content>
  </entry>
  
</feed>