<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Julia Evans]]></title>
  <link href="http://jvns.ca/atom.xml" rel="self"/>
  <link href="https://jvns.ca/categories/kernel/atom/index.xml"/>
  <updated>0001-01-01T00:00:00+00:00</updated>
  <id>http://jvns.ca</id>
  <author>
    <name><![CDATA[Julia Evans]]></name>
  </author>
  <generator uri="http://gohugo.io/">Hugo</generator>

  
  <entry>
    <title type="html"><![CDATA[Sendfile (a system call for web developers to know about!)]]></title>
    <link href="https://jvns.ca/blog/2016/01/23/sendfile-a-new-to-me-system-call/"/>
    <updated>2016-01-23T09:17:14+00:00</updated>
    <id>https://jvns.ca/blog/2016/01/23/sendfile-a-new-to-me-system-call/</id>
    <content type="html"><![CDATA[

<p>The other day I learned about a new (to me) exciting Linux system call! (for newcomers, a system call is an operation you can ask the operating system to do). This one seems really important to know about if you&rsquo;re configuring a webserver! So let&rsquo;s learn about it.</p>

<p>Before this, I knew about basic system calls like <code>open</code> and <code>read</code> for files, and <code>sendto</code> and <code>recvfrom</code> for networking. And a few fancier things like <code>futex</code> and <code>select</code> for mutexes and waiting.</p>

<h3 id="why-sendfile-was-invented">why sendfile was invented</h3>

<p>Suppose I want to send you a big file over a network connection. Normally I&rsquo;d just read the file incrementally, and then write the contents to the socket. So, at a minimum, we need to</p>

<ul>
<li>use <code>read</code> (requires a context switch into kernel code)</li>
<li>(implicitly, copy the data from kernel memory into user memory)</li>
<li>use <code>sendto</code> or <code>write</code> (another context switch)</li>
</ul>

<p>This means we need to copy data (bad) and use two system calls instead of one (also bad).</p>

<p>So the idea is &ndash; this pattern of reading a file and writing to a socket is really common! So they made a system call to just do that! Then the kernel can do all the work of reading and writing, and save you CPU time. And you don&rsquo;t need to copy any data around! AMAZING.</p>

<h3 id="the-performance-implications">the performance implications</h3>

<p>I found this <a href="https://code.google.com/p/pyftpdlib/issues/detail?id=152">google code discussion on a Python FTP library</a>. One person says that by using the <code>sendfile</code> system call, they could transfer 1.5GB/s instead of 800MB/s! That&rsquo;s pretty awesome for a small change.</p>

<p><a href="https://people.freebsd.org/~rrs/asiabsd_2015_tls.pdf">This paper from Netflix</a> describes using sendfile on FreeBSD to go from 6Gbps to 40Gbps of network throughput. They also talk about implementing (part of?) TLS in the kernel to improve TLS performance.</p>

<h3 id="the-disasters">the disasters</h3>

<p>I then read <a href="https://blog.phusion.nl/2015/06/04/the-brokenness-of-the-sendfile-system-call/">&ldquo;The brokenness of the sendfile() system call&rdquo;</a>. Wait?! But I thought sendfile was awesome and we should always use it? Not so!</p>

<p>That post describes how on OS X, <code>sendfile</code> wouldn&rsquo;t send <strong>any</strong> data until the socket was closed, causing up to 5 second delays. That&rsquo;s TERRIBLE. So sendfile isn&rsquo;t some kind of universal panacea, and that&rsquo;s why webservers let you turn it on and off.</p>

<h3 id="some-other-reading-on-sendfile">some other reading on sendfile</h3>

<p><a href="https://groups.google.com/forum/#!msg/golang-nuts/gdp1q6T0DNY/sFaRetnWPWIJ">Rob Pike (one of the creators of Go) thinks sendfile is &ldquo;bizarre&rdquo;</a>. I find his argument in that post pretty difficult to follow (if the kernel provides a way to do something, and that way gives you better performance in practice, why not use it?). But I thought it was interesting.</p>

<p><a href="http://tia.mat.br/posts/2014/10/06/life_of_a_http_request.html">Life of a HTTP request, as seen by my toy web server</a> is interesting, and describes how the author uses <code>sendfile</code> for large files, but not for small files. You don&rsquo;t need to write your own webserver to take advantage of this &ndash; you can configure apache and nginx to use sendfile!</p>

<p><a href="http://man7.org/linux/man-pages/man2/sendfile.2.html">The sendfile man page</a> is actually quite readable, and it tells you something very important! It recommends using the <code>TCP_CORK</code> TCP option for better network performance. We learned about how understanding TCP is important in <a href="http://jvns.ca/blog/2015/11/21/why-you-should-understand-a-little-about-tcp/">Why you should understand (a little) about TCP</a>, and that&rsquo;s pretty important here as well. In this case you need to decide whether to use <code>TCP_CORK</code> and <code>TCP_NODELAY</code>. One thing I read recommended using both.</p>

<p>You can also use sendfile to copy files quickly! (like, think about how <code>cp</code> is implemented!) <a href="http://blog.plenz.com/2014-04/so-you-want-to-write-to-a-file-real-fast.html">So you want to write to a file real fast&hellip;</a> walks through some optimizations to file copying and gets a 25% improvement by using <code>sendfile</code> and other tricks. I straced <code>cp</code> on my machine just now, and it seems like it does not use <code>sendfile</code>. It&rsquo;s super interesting to me how much abstractions break down when you&rsquo;re trying to really optimize performance.</p>

<h3 id="next-step-splice-tee">next step: <code>splice</code> &amp; <code>tee</code></h3>

<p>These days <code>sendfile</code> is a wrapper around the <code>splice</code> system call, which seems to be the same thing &ndash; copy data from one file/pipe/socket to another &ndash; but with some extra options.</p>

<p>There&rsquo;s <a href="https://web.archive.org/web/20130521163124/http://kerneltrap.org/node/6505">a neat thread on the Linux Kernel Mailing List from 2006</a>, just after those system calls came into existence, where Linus explains what they&rsquo;re for and how to think about them.</p>

<p>I found this paragraph helpful:</p>

<blockquote>
<p>Anyway, when would you actually <em>use</em> a kernel buffer? Normally you&rsquo;d use it
it you want to copy things from one source into another, and you don&rsquo;t
actually want to see the data you are copying, so using a kernel buffer allows
you to possibly do it more efficiently, and you can avoid allocating user VM
space for it</p>
</blockquote>

<p>That post also makes it clear that <code>sendfile</code> used to be a separate system call and is now just a wrapper around <code>splice</code>.</p>

<p>There&rsquo;s also <code>vmsplice</code>, which I think is related and important. But right now my brain is full. Maybe we&rsquo;ll learn about vmsplice later.</p>

<h3 id="why-this-is-amazing">why this is amazing</h3>

<p>It makes me really happy when learning a new system call helps me understand how to do something really practical. Now I know that if I&rsquo;m building something that serves large files and I care about the performance, I should make sure I understand if it&rsquo;s using sendfile!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guessing Linux kernel registers]]></title>
    <link href="https://jvns.ca/blog/2016/01/18/guessing-linux-kernel-registers/"/>
    <updated>2016-01-18T12:05:27+00:00</updated>
    <id>https://jvns.ca/blog/2016/01/18/guessing-linux-kernel-registers/</id>
    <content type="html"><![CDATA[

<p>I have a long-standing project to try to learn to use ftrace, a Linux kernel tracing tool. As usual when I want to learn more, I turned to one of <a href="http://brendangregg.com">Brendan Gregg</a>&rsquo;s tools &ndash; the <a href="https://github.com/brendangregg/perf-tools/">perf-tools</a> repo on Github. There&rsquo;s a whole delightful directory of <a href="https://github.com/brendangregg/perf-tools/blob/master/examples/">examples</a>. It&rsquo;s the best.</p>

<p>He has a lot of tools that are ready to use and easy to understand &ndash; for instance, you can use execsnoop to see every program that&rsquo;s being executed. Those are awesome.</p>

<p>Then there are some that require&hellip; more work. I was interested in ftrace, and I was using his kprobe script to trace system calls and their arguments.</p>

<p>I started out by running <code>sudo kernel/kprobe 'p:SyS_read'</code> to tell me every time the <code>read</code> system call happened. This gives me output like</p>

<pre><code> Chrome_ChildIOT-8978  [000] d...  7402.349880: SyS_read: (SyS_read+0x0/0xa0)
 Chrome_ChildIOT-4102  [002] d...  7402.349922: SyS_read: (SyS_read+0x0/0xa0)
            Xorg-1853  [001] d...  7402.349962: SyS_read: (SyS_read+0x0/0xa0)
            Xorg-1853  [001] d...  7402.349969: SyS_read: (SyS_read+0x0/0xa0)
 Chrome_IOThread-4092  [003] d...  7402.349974: SyS_read: (SyS_read+0x0/0xa0)
</code></pre>

<p>But WHAT FILE DID IT READ? This is not good at all.</p>

<p>In the <a href="https://github.com/brendangregg/perf-tools/blob/master/examples/kprobe_example.txt#L108-L127">example</a>, he says, on the open system call.</p>

<blockquote>
<p>Here I guessed that the mode was in register %cx, and cast it as a 16-bit
unsigned integer (&rdquo;:u16&rdquo;). Your platform and kernel may be different, and the
mode may be in a different register. If fiddling with such registers becomes
too painful or unreliable for you, consider installing kernel debuginfo and
using the named variables with perf_events &ldquo;perf probe&rdquo;.</p>
</blockquote>

<p>This was wizardry. How could he <em>guess</em> that the mode of a file was in the register <code>%cx</code>? What even are the registers? This makes no sense.</p>

<p>I partly figured this out and got more information about the <code>read</code> system calls, so I will now tell you!</p>

<h3 id="what-even-is-a-register">what even is a register</h3>

<p>I know that registers are what the CPU uses to store data in when calculating things. But how many even are there? How do I guess which one is right?</p>

<p>First, I found <a href="http://www.eecg.toronto.edu/~amza/www.mindsec.com/files/x86regs.html">this page describing x86 registers</a>. It tells me that there are</p>

<pre><code>General registers
EAX EBX ECX EDX

Segment registers
CS DS ES FS GS SS

Index and pointers
ESI EDI EBP EIP ESP
</code></pre>

<p>From the description, the segment registers seem safe to ignore! Awesome. The instruction pointer and the stack pointer tell me what instruction is running right now and where the stack is. I also don&rsquo;t care about that. So that leaves me with only 7 registers to worry about (eax, ebx, ecx, edx, esi, edi, and ebp). That&rsquo;s way better.</p>

<h3 id="printing-the-registers">printing the registers</h3>

<p>So before we were running <code>sudo kernel/kprobe 'p:SyS_read'</code>. We can also print the registers for the read system call! Here goes. For some reason we need to take off the <code>e</code>.</p>

<pre><code>sudo kernel/kprobe 'p:SyS_read ax=%ax bx=%bx cx=%cx dx=%dx si=%si di=%di' | grep chrome-4095
          chrome-4095  [001] d...  7665.279404: SyS_read: (SyS_read+0x0/0xa0) ax=0 bx=2cb4726adec0 cx=0 dx=2 si=7fff1282f70e di=9
          chrome-4095  [001] d...  7665.279562: SyS_read: (SyS_read+0x0/0xa0) ax=0 bx=2cb4726adec0 cx=0 dx=2 si=7fff1282f70e di=9
          chrome-4095  [002] d...  7665.400594: SyS_read: (SyS_read+0x0/0xa0) ax=0 bx=2cb4726adec0 cx=0 dx=2 si=7fff1282f70e di=9
</code></pre>

<p>Let&rsquo;s compare this to the output of strace:</p>

<pre><code>sudo strace -e read -p 4095
Process 4095 attached - interrupt to quit
read(9, &quot;!&quot;, 2)                         = 1
read(9, &quot;!&quot;, 2)                         = 1
read(9, &quot;!&quot;, 2)                         = 1
</code></pre>

<p>Ok, awesome! In the output of <code>strace</code>. I know that <code>9</code> is the file descriptor, 2 is the length to read, and the middle value is the string. This must mean that <code>%di</code> is the file descriptor, and <code>%dx</code> is the amount of data to read!</p>

<p>I can label those now and be a register-guessing-wizard like Brendan Gregg!</p>

<pre><code>sudo kernel/kprobe 'p:julia_smart_read SyS_read fd=%di:u16 bytes_to_read=%dx' | grep chrome-4095
          chrome-4095  [003] d...  7854.905089: julia_smart_read: (SyS_read+0x0/0xa0) fd=9 bytes_to_read=2
          chrome-4095  [003] d...  7854.945585: julia_smart_read: (SyS_read+0x0/0xa0) fd=9 bytes_to_read=2
          chrome-4095  [002] d...  7854.945852: julia_smart_read: (SyS_read+0x0/0xa0) fd=9 bytes_to_read=2
</code></pre>

<p>So now I know which file descriptors are being read!</p>

<p>The advantage of using ftrace instead of strace is that the overhead is way lower: when I strace <code>find</code> it makes it 20x slower, but with ftrace it&rsquo;s totally okay. I&rsquo;m still not sure where the string that we read is (I think it&rsquo;s in <code>%si</code>, though!)</p>

<p>Now I am one step closer to being able to trace system calls with less overhead. Guessing registers is really tedious but it seems to be totally possible!</p>

<p><strong>update</strong>: turns out you don&rsquo;t have to guess at all! the registers used for system calls are always the same :D. <a href="http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64">here is a table with all the answers ❤</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[You can be a kernel hacker!]]></title>
    <link href="https://jvns.ca/blog/2014/09/18/you-can-be-a-kernel-hacker/"/>
    <updated>2014-09-18T14:20:56+00:00</updated>
    <id>https://jvns.ca/blog/2014/09/18/you-can-be-a-kernel-hacker/</id>
    <content type="html"><![CDATA[<p><small> This blog post is adapted from a talk I gave at Strange Loop
2014 with the same title. <a href="https://www.youtube.com/watch?v=0IQlpFWTFbM">Watch the video!</a> </small></p>

<p>When I started <a href="https://hackerschool.com">Hacker School</a>, I wanted to
learn how the Linux kernel works. I&rsquo;d been using Linux for ten years,
but I still didn&rsquo;t understand very well what my kernel did. While
there, I found out that:</p>

<ul>
<li>the Linux kernel source code isn&rsquo;t all totally impossible to
understand</li>
<li>kernel programming is not just for wizards, it can also be for me!</li>
<li>systems programming is REALLY INTERESTING</li>
<li>I could write toy kernel modules, for fun!</li>
<li>and, most surprisingly of all, all of this stuff was <em>useful</em>.</li>
</ul>

<p>I hadn&rsquo;t been doing low level programming at all &ndash; I&rsquo;d written a
little bit of C in university, and otherwise had been doing web
development and machine learning. But it turned out that my newfound
operating systems knowledge helped me solve regular programming tasks
more easily.</p>

<p>I also now feel like if I were to be put on <em>Survivor: fix a bug in my
kernel&rsquo;s USB driver</em>, I&rsquo;d stand a chance of not being immediately
kicked off the island.</p>

<p></p>

<p>This is all going to be about Linux, but a lot of the same concepts
apply to OS X. We&rsquo;ll talk about</p>

<ul>
<li>what even is a kernel?</li>
<li>why bother learning about this stuff?</li>
<li>A few strategies for understanding the Linux kernel better, on your own
terms:

<ul>
<li>strace all the things!</li>
<li>Read some kernel code!</li>
<li>Write a fun kernel module!</li>
<li>Write an operating system!</li>
<li>Try the Eudyptula challenge</li>
<li>Do an internship.</li>
</ul></li>
</ul>

<h3 id="what-even-is-a-kernel">What even is a kernel?</h3>

<p>In a few words:</p>

<p><strong>A kernel is a bunch of code that knows how to interact with your hardware</strong>.</p>

<p>Linux is mostly written in C, with bit of assembly. Let&rsquo;s say you go
to <a href="http://google.com">http://google.com</a> in your browser. That requires typing, sending
data over a network, allocating some memory, and maybe writing some
cache files. Your kernel has code that</p>

<ul>
<li>interprets your keypresses every time you press a key</li>
<li>speaks the TCP/IP protocol, for sending information over the network
to Google</li>
<li>communicates with your hard drive to write bytes to it</li>
<li>understands how your filesystem is implemented (what do the bytes on
the hard drive even mean?!)</li>
<li>gives CPU time to all the different processes that might be running</li>
<li>speaks to your graphics card to display the page</li>
<li>keeps track of all the memory that&rsquo;s been allocated</li>
</ul>

<p>and much, much more. All of that code is running all the time you&rsquo;re
using your computer!</p>

<p>This is a lot to handle all at once! The only concept I want to you to
understand for the rest of this post is *<em>system calls</em>. System calls
are your kernel&rsquo;s API &ndash; regular programs that you write can interact
with your computer&rsquo;s hardware using system calls. A few example system
calls:</p>

<ul>
<li><code>open</code> opens files</li>
<li><code>sendto</code> and <code>recvfrom</code> send and receive network data</li>
<li><code>write</code> writes to disk</li>
<li><code>chmod</code> changes the permissions of a file</li>
<li><code>brk</code> and <code>sbrk</code> allocate memory</li>
</ul>

<p>So when you call the <code>open()</code> function in Python, somewhere down the
stack that eventually uses the <code>open</code> system call.</p>

<p>That&rsquo;s all you need to know about the kernel for now! It&rsquo;s a bunch of
C code that&rsquo;s running all the time on your computer, and you interact
with it using system calls.</p>

<h3 id="why-learn-about-the-linux-kernel-anyway">Why learn about the Linux kernel, anyway?</h3>

<p>There are some obvious reasons: it&rsquo;s really fun! Not everyone knows
about it! Saying you wrote a kernel module for fun is cool!</p>

<p>But there&rsquo;s a more serious reason: learning about the interface
between your operating system and your programs will <strong>make you a
better programmer</strong>. Let&rsquo;s see how!</p>

<h4 id="reason-1-strace">Reason 1: strace</h4>

<p>Imagine that you&rsquo;re writing a Python program, and it&rsquo;s meant to be
reading some data from a file <code>/user/bork/awesome.txt</code>. But it&rsquo;s not
working!</p>

<p>A pretty basic question is: is your program even opening the right
file? You could start using your regular debugging techniques to
investigate (print some things out! use a debugger!). But the amazing
thing is that on Linux, the <em>only way</em> to open a file is with the
<code>open</code> system call. You can get a list of all of these calls to <code>open</code>
(and therefore every file your program has opened) with a tool called
strace.</p>

<p>Let&rsquo;s do a quick example! Let&rsquo;s imagine I want to know what files
Chrome has opened!</p>

<pre><code>$ strace -e open google-chrome
[... lots of output omitted ...]
open(&quot;/home/bork/.config/google-chrome/Consent To Send Stats&quot;, O_RDONLY) = 36
open(&quot;/proc/meminfo&quot;, O_RDONLY|O_CLOEXEC) = 36
open(&quot;/etc/opt/chrome/policies/managed/lastpass_policy.json&quot;, O_RDONLY) = 36
</code></pre>

<p>This is a really powerful tool for observing the <em>behavior</em> for a
program that we wouldn&rsquo;t have if we didn&rsquo;t understand some basics
about system calls. I use strace to:</p>

<ul>
<li>see if the file I <em>think</em> my program is opening is what it&rsquo;s
<em>really</em> opening (system call: <code>read</code>)</li>
<li>find out what log file my misbehaving poorly documented program is
writing to (though I could also use <code>lsof</code>) (system call: <code>write</code>)</li>
<li>spy on what data my program is sending over the network (system
calls: <code>sendto</code> and <code>recvfrom</code>)</li>
<li>find out every time my program opens a network connection (system
call: <code>socket</code>)</li>
</ul>

<p>I love strace so much I gave a lightning talk about just strace:
<a href="https://www.youtube.com/watch?v=4pEHfGKB-OE">Spying on your programs with strace</a>.</p>

<h4 id="reason-2-proc">Reason 2: <code>/proc</code></h4>

<p><code>/proc</code> lets you <strong>recover your deleted files</strong>, and is a great
example of how understanding your operating system a little better is
an amazing programming tool.</p>

<p>How does it do that? Let&rsquo;s imagine that we&rsquo;ve written a program
<a href="https://gist.github.com/jvns/a5c1ac3c141a6a6e782f">smile.c</a>, and
we&rsquo;re in the middle of running it. But then we accidentally delete the
binary!</p>

<p>The PID of that process right now is <code>8604</code>. I can find the
executable for that process at <code>/proc/8604/exe</code>:</p>

<pre><code> /proc/8604/exe -&gt; /home/bork/work/talks/2014-09-strangeloop/smile (deleted)
</code></pre>

<p>It&rsquo;s <code>(deleted)</code>, but we can still look at it!
<code>cat /proc/8604/exe &gt; recovered_smile</code> will recover our executable. Wow.</p>

<p>There&rsquo;s also a ton of other really useful information about processes
in <code>/proc</code>. (like which files they have open &ndash; try <code>ls -l/proc/&lt;pid&gt;/fd</code>)</p>

<p>You can find out more with <code>man proc</code>.</p>

<h4 id="reason-3-ftrace">Reason 3: ftrace</h4>

<p>ftrace is totally different from strace. strace traces <strong>system
calls</strong> and ftrace traces <strong>kernel functions</strong>.</p>

<p>I honestly haven&rsquo;t had occasion to do this yet but it is REALLY COOL
so I am telling you about it. Imagine that you&rsquo;re having some problems
with TCP, and you&rsquo;re seeing a lot of TCP retransmits. ftrace can give
you information about every time the TCP retransmit function in the
kernel is called!</p>

<p>To see how to actually do this, read Brendan Gregg&rsquo;s post
<a href="http://www.brendangregg.com/blog/2014-09-06/linux-ftrace-tcp-retransmit-tracing.html">Linux ftrace TCP Retransmit Tracing</a>.</p>

<p>There also appear to be some articles about ftrace on
<a href="https://www.google.ca/search?q=lwn+ftrace">Linux Weekly News!</a></p>

<p>I dream of one day actually investigating this :)</p>

<h4 id="reason-4-perf">Reason 4: perf</h4>

<p>Your CPU has a whole bunch of different levels of caching (L1! L2!)
that can have really significant impacts on performance. <code>perf</code> is a
great tool that can tell you</p>

<ul>
<li>how often the different caches are being used (how many L1 cache
misses are there?)</li>
<li>how many CPU cycles your program used (!!)</li>
<li>profiling information (how much time was spent in each function?)</li>
</ul>

<p>and a whole bunch of other insanely useful performance information.</p>

<p>If you want to know more about awesome CPU cycle tracking, I wrote
about it in
<a href="http://jvns.ca/blog/2014/05/13/profiling-with-perf/">I can spy on my CPU cycles with perf!</a>.</p>

<h4 id="convinced-yet">Convinced yet?</h4>

<p>Understanding your operating system better is <em>super useful</em> and will
make you a better programmer, even if you write Python. The most
useful tools for high-level programming I&rsquo;ve found <code>strace</code> and
<code>/proc</code>. As far as I can tell ftrace and perf are mostly useful for
lower-level programming. There&rsquo;s also <code>tcpdump</code> and <code>lsof</code> and
<code>netstat</code> and all kinds of things I won&rsquo;t go into here.</p>

<p>Now you&rsquo;re hopefully convinced that learning more about Linux is worth
your time. Let&rsquo;s go over some strategies for understanding Linux
better!</p>

<h3 id="strategy-1-strace-all-the-things">Strategy 1: strace all the things!</h3>

<p>I mentioned <code>strace</code> before briefly. <code>strace</code> is literally my favorite
program in the universe. A great way to get a better sense for what
your kernel is doing is &ndash; take a simple program that you understand
well (like <code>ls</code>), and run <code>strace</code> on it.</p>

<p>This will show you at what points the program is communicating with
your kernel. I took a 13 hour train ride from Montreal to New York
once and
<a href="http://jvns.ca/blog/2013/12/22/fun-with-strace/">straced killall</a> and
it was REALLY FUN. Let&rsquo;s try <code>ls</code>!</p>

<p>I ran <code>strace -o out ls</code> to save the output to a file. strace will
output a
<a href="https://gist.github.com/jvns/291a4de261cb326585c7">WHOLE BUNCH OF CRAP</a>.
It turns out that starting up a program is pretty complicated, and in
this case most of the system calls have to do with that. There&rsquo;s a lot
of</p>

<ul>
<li>opening libraries: <code>open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,
O_RDONLY|O_CLOEXEC)</code></li>
<li>putting those libraries into memory: <code>mmap(NULL, 2126312,
PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7faf507fc000
</code></li>
</ul>

<p>and a bunch of other things I don&rsquo;t really understand. My main
strategy when stracing for fun is to ignore all the crap at the
beginning, and just focus on what I understand. It turns out that <code>ls</code>
doesn&rsquo;t need to do a lot!</p>

<pre><code>openat(AT_FDCWD, &quot;.&quot;, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC) = 3
getdents(3, /* 5 entries */, 32768)     = 136
getdents(3, /* 0 entries */, 32768)     = 0
close(3)                                = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 12), ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7faf5104a000
write(1, &quot;giraffe  out  penguin\n&quot;, 22) = 22
close(1)                                = 0
munmap(0x7faf5104a000, 4096)            = 0
close(2)                                = 0
exit_group(0)                           = ?
</code></pre>

<p>This is awesome! Here&rsquo;s what it needed to do:</p>

<ol>
<li>Open the current directory: <code>openat(AT_FDCWD, &quot;.&quot;,
O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC)</code></li>
<li>Get the contents of that directory: <code>getdents(3, /* 5 entries */,
32768) = 136</code>. Looks like it was 136 bytes of stuff!</li>
<li>Close the directory: <code>close(3)</code></li>
<li>Write the files to standard out: <code>write(1, &quot;giraffe out penguin\n&quot;,
22) = 22</code></li>
<li>Close a bunch of things to clean up.</li>
</ol>

<p>That was really simple, and we already learned a new system call! That
mmap in the middle there? No idea what that does. But it&rsquo;s totally
fine! STRACE IS THE BEST.</p>

<p>So! Running strace on random processes and looking up the
documentation for system calls you don&rsquo;t recognize is an easy way to
learn a ton!</p>

<p><strong><span style='color:red'>Warning</span></strong>: <strong>Don&rsquo;t</strong> strace processes
that you actually need to run efficiently! strace is like putting a
huge stopsign in front of your process every time you use a system
call, which is <strong>all the time</strong>. Brendan Gregg has a
<a href="http://www.brendangregg.com/blog/2014-05-11/strace-wow-much-syscall.html">great post about strace which you should read</a>.
Also you should probably read everything he writes.</p>

<h3 id="strategy-2-read-some-kernel-code">Strategy 2: Read some kernel code!</h3>

<p>Okay, let&rsquo;s imagine that we&rsquo;ve gotten interested in <code>getdents</code> (the
system call to list the contents of a directory), and we want to
understand better what it actually does. There&rsquo;s this fantastic tool
called <a href="http://livegrep.com">livegrep</a> that lets you search through
kernel code. It&rsquo;s by <a href="http://twitter.com/nelhage">Nelson Elhage</a> who
is pretty great.</p>

<p>So let&rsquo;s use it to find the source for <code>getdents</code>, which lists all the
entries in a directory! I searched for it
using livegrep, and found
<a href="https://github.com/torvalds/linux/blob/v3.13/fs/readdir.c#L192-L223">the source</a>.</p>

<p>On line 211, it calls <code>iterate_dir</code>. So let&rsquo;s look that up! It&rsquo;s
<a href="https://github.com/torvalds/linux/blob/v3.13/fs/readdir.c#L23-L48">here</a>.
Honestly this code makes no sense to me (maybe <code>res =
file-&gt;f_op-&gt;iterate(file, ctx)</code> is what&rsquo;s iterating over the directory?).</p>

<p>But it&rsquo;s neat that we can look at it!</p>

<p>If you want to know about current Linux kernel development,
<a href="http://lwn.net/">Linux Weekly News</a> is a great resource. For example,
here&rsquo;s an interesting article about the
<a href="http://lwn.net/Articles/342892/">btrfs filesystem!</a></p>

<h3 id="strategy-3-write-a-fun-kernel-module">Strategy 3: Write a fun kernel module!</h3>

<p>Kernel modules sound intimidating but they&rsquo;re actually really
approachable! All a kernel module is fundamentally is</p>

<ol>
<li>An <code>init</code> function to run when the module is loaded</li>
<li>A <code>cleanup</code> function to run when the module is unloaded</li>
</ol>

<p>You load kernel modules with <code>insmod</code> and unload them with <code>rmmod</code>.
Here&rsquo;s a working &ldquo;Hello world&rdquo; kernel module!</p>

<pre><code>#include &lt;linux/module.h&gt;    // included for all kernel modules
#include &lt;linux/kernel.h&gt;    // included for KERN_INFO
#include &lt;linux/init.h&gt;      // included for __init and __exit macros

static int __init hello_init(void)
{
    printk(KERN_INFO &quot;WOW I AM A KERNEL HACKERl!!!\n&quot;);
    return 0;    // Non-zero return means that the module couldn't be loaded.
}

static void __exit hello_cleanup(void)
{
  printk(KERN_INFO &quot;I am dead.\n&quot;);
}

module_init(hello_init);
module_exit(hello_cleanup);
</code></pre>

<p>That&rsquo;s it! <code>printk</code> writes to the system log, and if you run <code>dmesg</code>,
you&rsquo;ll see what it printed!</p>

<p>Let&rsquo;s look at another fun kernel module! I gave a talk about kernel
hacing at <a href="http://2014.cusec.net">CUSEC</a> in January, and I needed a
fun example. My friend <a href="https://twitter.com/tavarm">Tavish</a> suggested
&ldquo;hey julia! What if you made a kernel module that rick rolls you every
time you open a file?&rdquo; And my awesome partner
<a href="https://twitter.com/kamalmarhubi">Kamal</a> said &ldquo;that sounds like fun!&rdquo;
and inside a weekend he&rsquo;d totally done it!</p>

<p>You can see the <em>extremely</em> well-commented source here:
<a href="https://github.com/jvns/kernel-module-fun/blob/master/rickroll.c">rickroll.c</a>.
Basically what it needs to do when loaded is</p>

<ul>
<li>find the system call table (it turns out this is not trivial!)</li>
<li>Disable write protection so that we&rsquo;re actually allowed to modify it
(!!)</li>
<li>Save the old <code>open</code> so we can put it back</li>
<li>Replace the <code>open</code> system call with our own <code>rickroll_open</code> system
call</li>
</ul>

<p>That&rsquo;s it!</p>

<p>Here&rsquo;s the relevant code:</p>

<pre><code>sys_call_table = find_sys_call_table();
DISABLE_WRITE_PROTECTION;
original_sys_open = (void *) sys_call_table[__NR_open];
sys_call_table[__NR_open] = (unsigned long *) rickroll_open;
ENABLE_WRITE_PROTECTION;
printk(KERN_INFO &quot;Never gonna give you up!\n&quot;);
</code></pre>

<p>The <code>rickroll_open</code> function is also pretty understandable. Here&rsquo;s a
sketch of it, though I&rsquo;ve left out some important implementation
details that you should totally read: <a href="https://github.com/jvns/blob/master/rickroll.c">rickroll.c</a></p>

<pre><code>static char *rickroll_filename = &quot;/home/bork/media/music/Rick Astley - Never Gonna Give You Up.mp3&quot;;
asmlinkage long rickroll_open(const char __user *filename, int flags, umode_t mode) {
    if(strcmp(filename + len - 4, &quot;.mp3&quot;)) {
        /* Just pass through to the real sys_open if the extension isn't .mp3 */
        return (*original_sys_open)(filename, flags, mode);
    } else {
        /* Otherwise we're going to hijack the open */ fd =
        (*original_sys_open)(rickroll_filename, flags, mode); return
        fd; } }
</code></pre>

<p>SO FUN RIGHT. The source is super well documented and interesting and
you should
<a href="https://github.com/jvns/kernel-module-fun/blob/master/rickroll.c">go read it</a>.
And if you think &ldquo;but Kamal must be a kernel hacking wizard! I could
never do that!&ldquo;, it is not so! Kamal is pretty great, but he had never
written kernel code before that weekend. I understand that he googled
things like &ldquo;how to hijack system call table linux&rdquo;. You could do the
same!</p>

<p>Kernel modules are an especially nice way to start because writing toy
kernel modules plays nicely into writing real kernel modules like
hardware drivers. Or you could start out writing drivers right away!
Whatever floats your boat :) The reference for learning about writing
drivers is called <a href="http://lwn.net/Kernel/LDD3/">Linux Device Drivers</a>
or &ldquo;LDD3&rdquo;. The fabulous
<a href="http://web.mit.edu/jesstess/www/">Jessica McKellar</a> is writing the
new version, LDD4.</p>

<h3 id="strategy-4-write-an-operating-system">Strategy 4: Write an operating system!</h3>

<p>This sounds really unapproachable! And writing a full-featured
operating system from scratch is a <strong>ton</strong> of work. But the great
thing about operating systems is that yours don&rsquo;t need to be full-featured!</p>

<p>I wrote a <a href="https://github.com/jvns/puddle">small operating system</a>
that basically only has a keyboard driver. And doesn&rsquo;t compile for
anyone except me. It was 3 weeks of work, and I learned SO MUCH.
There&rsquo;s a <a href="http://wiki.osdev.org/Main_Page">super great wiki</a> with
lots of information about making operating system.</p>

<p>A few of the blog posts that I wrote while working on it:</p>

<ul>
<li><a href="http://jvns.ca/blog/2014/03/12/the-rust-os-story/">Writing an OS in Rust in tiny steps</a></li>
<li><a href="http://jvns.ca/blog/2013/12/04/day-37-how-a-keyboard-works/">After 5 days, my OS doesn’t crash when I press a key</a></li>
<li><a href="http://jvns.ca/blog/2013/12/16/day-43-hopefully-the-last-day-spent-fixing-linker-problems/">SOMETHING IS ERASING MY PROGRAM WHILE IT’S RUNNING (oh wait oops)</a></li>
</ul>

<p>I learned about linkers and bootloaders and interrupts and memory
management and how executing a program works and so many more things!
And I&rsquo;ll never finish it,
<a href="http://jvns.ca/blog/2014/03/21/my-rust-os-will-never-be-finished/">and that&rsquo;s okay</a>.</p>

<h3 id="strategy-5-do-the-eudyptula-challenge">Strategy 5: Do the Eudyptula challenge</h3>

<p>If you don&rsquo;t have an infinite number of ideas for hilarious kernel
module pranks to play on your friends (I certainly don&rsquo;t!), the
<a href="http://eudyptula-challenge.org/">Eudyptula Challenge</a> is specifically
built to help you get started with kernel programming, with
progressively harder steps. The first one is to just write a
&ldquo;hello world&rdquo; kernel module, which is pretty straightforward!</p>

<p>They&rsquo;re pretty strict about the way you send email (helping you
practice for the linux kernel mailing list, maybe!). I haven&rsquo;t tried
it myself yet, but <a href="http://nullspace.io">Alex Clemmer</a> tells me that
it is hard but possible. Try it out!</p>

<h3 id="strategy-6-do-an-internship">Strategy 6: Do an internship</h3>

<p>If you&rsquo;re really serious about all this, there are a couple of
programs I know of:</p>

<ul>
<li>Google Summer of Code, for students</li>
<li>The GNOME outreach program for women</li>
</ul>

<p>The GNOME outreach program for women (OPW) is a great program that
provides mentorship and a 3-month paid internship for women who would
like to contribute to the Linux kernel.
<a href="http://sarah.thesharps.us/2014/08/27/2014-kernel-internship-report-opw/">More than 1000 patches</a>
from OPW interns and alumni have been accepted into the kernel.</p>

<p>In the application you submit a simple patch to the kernel (!!), and
it&rsquo;s very well documented. You don&rsquo;t need to be an expert, though you
do need to know some C.</p>

<p><strong>You can apply now!</strong> The application deadline for the current round
is October 31, 2014, and you can find more information on the
<a href="http://kernelnewbies.org/OPWIntro">kernel OPW website</a>.</p>

<h3 id="resources">Resources</h3>

<p>To recap, here are a few super useful resources for learning that I&rsquo;ve
mentioned:</p>

<ul>
<li>Previous writing:
<a href="http://jvns.ca/blog/2014/01/04/4-paths-to-being-a-kernel-hacker/">4 paths to being a kernel hacker</a>,
everything I&rsquo;ve written about <a href="http://jvns.ca/blog/categories/kernel/">kernels</a></li>
<li>I learned all of this at <a href="https://www.hackerschool.com/">Hacker School</a></li>
<li><a href="http://lxr.linux.no/linux+v3.12.6/">LXR</a> and
<a href="http://livegrep.com/search/linux">http://livegrep.com/</a> are great
for searching the Linux kernel</li>
<li><a href="http://lwn.net/Kernel/LDD3/">Linux Device Drivers 3</a> is available
free online.</li>
<li>The <a href="http://kernelnewbies.org/OPWIntro">OPW internship for the Linux kernel</a></li>
<li>Linux Weekly News
(<a href="http://lwn.net/Archives/GuestIndex/">here&rsquo;s an index</a>)</li>
<li><a href="http://brendangregg.com/">Brendan Gregg</a> has a ton of extremely
useful writing about performance analysis tools like <code>perf</code> and
<code>ftrace</code> on Linux.</li>
</ul>

<h3 id="you-can-be-a-kernel-hacker">You can be a kernel hacker</h3>

<p>I&rsquo;m not a kernel hacker, really. But now when I look at awesome actual
kernel hackers like <a href="http://valerieaurora.org/">Valerie Aurora</a> or
<a href="http://sarah.thesharps.us/">Sarah Sharp</a>, I no longer think that
they&rsquo;re wizards. I now think those are people who worked really hard
on becoming better at kernel programming, and did it for a long time!
And if I spent a lot of time working on learning more, I could be a
kernel hacker too.</p>

<p>And so could you.</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I can spy on my CPU cycles with perf!]]></title>
    <link href="https://jvns.ca/blog/2014/05/13/profiling-with-perf/"/>
    <updated>2014-05-13T20:47:49+00:00</updated>
    <id>https://jvns.ca/blog/2014/05/13/profiling-with-perf/</id>
    <content type="html"><![CDATA[<p>Yesterday I talked about using <code>perf</code> to profile assembly
instructions. Today I learned how to make flame graphs with <code>perf</code>
today and it is THE BEST. I found this because
<a href="https://twitter.com/graydon_moz">Graydon Hoare</a> pointed me to Brendan
Gregg&rsquo;s <em>excellent</em>
<a href="http://www.brendangregg.com/perf.html">page on how to use perf</a>.</p>

<p>Wait up! What&rsquo;s <code>perf</code>? I&rsquo;ve talked about <code>strace</code> a lot before (in
<a href="http://jvns.ca/blog/2014/04/20/debug-your-programs-like-theyre-closed-source/">Debug your programs like they&rsquo;re closed source</a>).
<code>strace</code> lets you see which system calls a program is calling. But
what if you wanted to know</p>

<ul>
<li>how many CPU instructions it ran?</li>
<li>How many L1 cache misses there were?</li>
<li>profiling information for each assembly instruction?</li>
</ul>

<p><code>strace</code> only does system calls, and none of those things are system
calls. So it can&rsquo;t tell you any of those things!</p>

<p></p>

<p><code>perf</code> is a Linux tool that can tell you all of these things, and
more! Let&rsquo;s run a quick example on the
<a href="http://jvns.ca/blog/2014/05/12/computers-are-fast/">bytesum program from yesterday</a>.</p>

<pre>
bork@kiwi ~/w/howcomputer> perf stat ./bytesum_mmap *.mp4
 Performance counter stats for './bytesum_mmap The Newsroom S01E04.mp4':

        158.141639 task-clock                #    0.994 CPUs utilized          
                22 context-switches          #    0.139 K/sec                  
                 9 CPU-migrations            #    0.057 K/sec                  
               133 page-faults               #    0.841 K/sec                  
       438,662,273 cycles                    #    2.774 GHz                     [82.43%]
       269,916,782 stalled-cycles-frontend   #   61.53% frontend cycles idle    [82.38%]
       131,557,379 stalled-cycles-backend    #   29.99% backend  cycles idle    [66.66%]
       681,518,403 instructions              #    1.55  insns per cycle        
                                             #    0.40  stalled cycles per insn [84.88%]
       130,568,804 branches                  #  825.645 M/sec                   [84.85%]
            20,756 branch-misses             #    0.02% of all branches         [83.68%]

       0.159154389 seconds time elapsed
</pre>

<p>This is super neat information, and there&rsquo;s a lot more (see <code>perf
list</code>). But we can do even more fun things!</p>

<h3 id="flame-graphs-with-perf">Flame graphs with perf</h3>

<p>I wanted to profile my <code>bytesum</code> program. But how do you even profile
C programs? Here&rsquo;s a way to do it with <code>perf</code>:</p>

<pre>
sudo perf record -g ./bytesum_mmap *.mp4
sudo perf script | stackcollapse-perf.pl | flamegraph.pl > flamegraph.svg
</pre>

<p>Here&rsquo;s the SVG this gave me:</p>

<p><img src="/images/flamegraph.svg"></p>

<p>This is AMAZING. But what does it mean? Basically <code>perf</code> periodically
interrupts the program and finds out where in the stack it is. The
width of each part of the stack in the graph above is the proportion
of samples that happened there. (so about 30% of the execution time
was spend in <code>main</code>). I don&rsquo;t know what the colour means here.</p>

<p>We can see that there are 3 big parts &ndash; there&rsquo;s the <code>mmap</code> call (on
the left), the main program execution (in the middle), and the
<code>sys_exit</code> part on the right. Apparently stopping my program takes a
long time! Neat!</p>

<p>But there&rsquo;s more!</p>

<h3 id="is-it-really-l1-cache-misses-we-can-find-out">Is it really L1 cache misses? We can find out!</h3>

<p>So yesterday I made a program with really bad memory access patterns
(<a href="https://github.com/jvns/howcomputer/blob/master/bytesum_stride.c">bytesum_stride.c</a>),
and I conjectured that it was way slower because it was causing way
too many L1 cache misses.</p>

<p>But with <code>perf</code>, we can check if that&rsquo;s actually true! Here are the
results (reformatted a bit to be more compact):</p>

<pre>
bork@kiwi ~/w/howcomputer> perf stat -e L1-dcache-misses,L1-dcache-loads ./bytesum_mmap *.mp4
        17,175,214 L1-dcache-misses #   11.48% of all L1-dcache hits  
       149,568,438 L1-dcache-loads
bork@kiwi ~/w/howcomputer> perf stat -e L1-dcache-misses,L1-dcache-loads ./bytesum_stride *.mp4 1000
     1,031,902,483 L1-dcache-misses #  193.16% of all L1-dcache hits  
       534,219,219 L1-dcache-loads
</pre>

<p>So, uh, that&rsquo;s really bad. We now have <strong>60 times more</strong> L1 cache
misses, and also 3 times more hits.</p>

<h3 id="other-amazing-things">Other amazing things</h3>

<ul>
<li>Go to
<a href="http://www.brendangregg.com/perf.html">Brendan Gregg&rsquo;s perf page and read the whole thing</a>.
Also possibly everything he&rsquo;s ever written. His recent post on
<a href="http://www.brendangregg.com/blog/2014-05-11/strace-wow-much-syscall.html">strace</a>
is great too.</li>
<li>The <a href="https://perf.wiki.kernel.org/index.php/Tutorial">perf tutorial</a>
is pretty long, but I found it somewhat helpful.</li>
<li><a href="https://github.com/brendangregg/FlameGraph">FlameGraph!</a></li>
<li>I spent a little bit of time running cachegrind with
<code>valgrind --tool=cachegrind ./bytesum_mmap my_file</code>
which can give you possibly even more information about CPU caches
than <code>perf</code> can. Still haven&rsquo;t totally wrapped my head around this.</li>
</ul>

<p>There are still so many things I don&rsquo;t understand at all!</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debug your programs like they&#39;re closed source!]]></title>
    <link href="https://jvns.ca/blog/2014/04/20/debug-your-programs-like-theyre-closed-source/"/>
    <updated>2014-04-20T18:30:54+00:00</updated>
    <id>https://jvns.ca/blog/2014/04/20/debug-your-programs-like-theyre-closed-source/</id>
    <content type="html"><![CDATA[<p>Until very recently, if I was debugging a program, I practically
always did one of these three things:</p>

<ol>
<li>open a debugger</li>
<li>look at the source code</li>
<li>insert some print statements</li>
</ol>

<p>I&rsquo;ve started sometimes debugging a new way. With this method, I don&rsquo;t
look at the source code, don&rsquo;t edit the source code, and don&rsquo;t use a
debugger. I don&rsquo;t even need to have the program&rsquo;s source available to
me!</p>

<p>Can we repeat that again? I can look at the internal behavior of
<em>closed-source programs</em>.</p>

<p>How?!?! AM I A WIZARD? Nope. SYSTEM CALLS! What is a system call?
Operating systems know how to open files, display things to the
screen, start processes, and all kinds of things. Programs can ask
their operating system to do these things, using functions called
<strong>system calls</strong>.</p>

<p></p>

<p>System calls are the API for your computer, so you don&rsquo;t have to know
how a network card works to send a HTTP request.</p>

<p>Here&rsquo;s a list of the
<a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html">system calls Linux 2.2</a>
provides, to give you a sense for what&rsquo;s available. There&rsquo;s <code>exit</code>,
<code>open</code>, <code>read</code>, <code>write</code>, <code>time</code>, <code>mount</code>, <code>kill</code>, and all kinds of
other things. System calls are basically the definition of platform
specific (different operating system have different system calls), so
we&rsquo;re only going to be talking about Linux here.</p>

<p>How can we use these to debug? Here are a few of my favorite system
calls!</p>

<h2 id="open">open</h2>

<p><code>open</code> opens files. Every time any program opens a file it needs to
use the <code>open</code> system call. There&rsquo;s no other way.</p>

<p>So! Let&rsquo;s say you have a backup program on your computer, and you want
to know which files it&rsquo;s working on. And that it doesn&rsquo;t show you a
progress bar or have any options. Let&rsquo;s say that it has PID 60.</p>

<p>We can spy on this program with a tool called <code>strace</code> and print out
every file it opens! <code>strace</code> shows you which system calls a program
calls. To spy on our backup program, we would run <code>strace -e trace=open
-p 60</code>, to tell it to print all the <code>open</code> system calls from PID 60.</p>

<p>For example, I ran <code>strace -e trace=open ssh</code> and here were some of the
things I found:</p>

<pre>
open("/etc/ssh/ssh_config", O_RDONLY)   = 3
open("/home/bork/.ssh/config", O_RDONLY) = 3
open("/home/bork/.ssh/id_dsa", O_RDONLY) = 4
open("/home/bork/.ssh/id_dsa.pub", O_RDONLY) = 4
open("/home/bork/.ssh/id_rsa", O_RDONLY) = 4
open("/home/bork/.ssh/id_rsa.pub", O_RDONLY) = 4
open("/home/bork/.ssh/known_hosts", O_RDONLY) = 4
</pre>

<p>This makes total sense! <code>ssh</code> needs to read my private and public
keys, my local ssh config, and the global ssh config. Neat! <code>open</code> is
super simple and super useful.</p>

<h2 id="execve">execve</h2>

<p><code>execve</code> starts programs. All programs. There&rsquo;s no way to start a
program except to use <code>execve</code>. We can use <code>strace</code> to spy on <code>execve</code>
calls too!</p>

<p>For example! I was trying to understand a Ruby script that was
basically just running some <code>ssh</code> commands. I could have read the Ruby
code! But I really just wanted to know which damn command it was
running! I did this by running <code>strace -f -s3000 -e trace=execve</code> and
read zero code!</p>

<p>The <code>-f</code> option is super important here. It also tracks the system
calls of every subprocess! I basically use <code>-f</code> all the time. Use
<code>-f</code>.
(<a href="/blog/2014/02/26/using-strace-to-avoid-reading-ruby-code/">[longer blog post about using strace + execve to poke at Ruby programs]</a>).</p>

<h2 id="write">write</h2>

<p><code>write</code> writes to files. I think there are ways to write to a file
without using <code>write</code> (like by using <code>mmap</code>), but <em>usually</em> if a file
is being written to, it&rsquo;s using <code>write</code>.</p>

<p>If I <code>strace -e trace=write</code> on an <code>ssh</code> session, this is some of what
I see:</p>

<pre>
write(3, "SSH-2.0-OpenSSH_5.9p1 Debian-5ubuntu1.1\r\n", 41) = 41
[...]
write(5, "[jvns /home/public]$ ", 21)   = 21
write(3, "\242\227e\376\344\36\270\343\331\307\231\332\373\273\324\303X\n<\241p`\212\21\317\353`\1/\3629\273m\23\17\26\304\fJ\352z\210\2\210\211~7W", 48) = 48
write(5, "logout\r\n", 8)               = 8
write(3, "b\277\306\16!\6J\202\tF$\241\32\302\3\0\23\310\346f\241\233\263\254\325\351z\222\234\224\270\231", 32) = 32
write(3, "\311\372\353\273\233oU\226~\373N\227\323*S\263\307\272\204VzO \10\2\316\224\335X@Hj\26\366\271J:i6\311\240A\325\331\341\220\1%\233\240\23n\23\242\34\277\2139\376\31j\255\32h", 64) = 64
write(2, "Connection to ssh.phx.nearlyfreespeech.net closed.\r\n", 52) = 52
</pre>

<p>So it opens an SSH connection, writes a prompt to my terminal, sends
some (encrypted!) data over the connection, and prints that the
connection is closed! Neat! I understand a bit more about how ssh
works now!</p>

<h2 id="proc">/proc</h2>

<p>I want to talk about one more Linux thing, and it isn&rsquo;t a system call.
It&rsquo;s a directory called <code>/proc</code>! There are a million things that
<code>/proc</code> does, but this is my favorite:</p>

<p><code>/proc</code> tells you every file your process has open. All of them! For
example, one of my Chrome processes has PID 3823. If I run <code>ls -l
/proc/3823/fd/*</code>, it shows me all the files Chrome has open!</p>

<p><code>fd</code> stands for &ldquo;file descriptor&rdquo;.</p>

<pre>
$ ls -l /proc/3823/fd/*
total 0
lr-x------ 1 bork bork 64 Apr 19 09:28 0 -> /dev/null
l-wx------ 1 bork bork 64 Apr 19 09:28 1 -> /dev/null
lrwx------ 1 bork bork 64 Apr 19 09:28 10 -> socket:[16583]
lr-x------ 1 bork bork 64 Apr 19 09:28 100 -> /opt/google/chrome/nacl_irt_x86_64.nexe
lrwx------ 1 bork bork 64 Apr 19 09:28 101 -> /home/bork/.config/google-chrome/Default/Application Cache/Cache/index
lrwx------ 1 bork bork 64 Apr 19 09:28 102 -> /home/bork/.config/google-chrome/Default/Application Cache/Cache/data_0
lrwx------ 1 bork bork 64 Apr 19 09:28 103 -> socket:[178726]
lrwx------ 1 bork bork 64 Apr 19 09:28 104 -> socket:[21064]
lrwx------ 1 bork bork 64 Apr 19 09:28 105 -> /home/bork/.config/google-chrome/Default/Application Cache/Cache/data_1
lrwx------ 1 bork bork 64 Apr 19 09:28 106 -> /home/bork/.config/google-chrome/Default/Application Cache/Cache/data_2
lrwx------ 1 bork bork 64 Apr 19 09:28 107 -> /home/bork/.config/google-chrome/Default/Application Cache/Cache/data_3
</pre>

<p>aaaand a million more. This is great. There are also a ton more things
in <code>/proc/3823</code>. Look around! I wrote a bit more about <code>/proc</code> in
<a href="http://jvns.ca/blog/2014/03/23/recovering-files-using-slash-proc-and-other-useful-facts/">Recovering files using /proc (and spying, too!)</a>.</p>

<h2 id="ltrace-beyond-system-calls">ltrace: beyond system calls!</h2>

<p>Lots of things happen outside of the kernel. Like string comparisons!
I don&rsquo;t need a network card for that! What if we wanted to know about
those? <code>strace</code> won&rsquo;t help us at all. But <code>ltrace</code> will!</p>

<p>Let&rsquo;s try running <code>ltrace killall firefox</code>. We see a bunch of things
like this:</p>

<pre>
fopen("/proc/10578/stat", "r")                               => 0x11984f0
free(0x011984d0)
fscanf(0x11984f0, 0x403fe7, 0x7fff09984980, 0x7f2fc7cd4728, 0)
fclose(0x11984f0)
strcmp("firefox", "kworker/u:0")
</pre>

<p>So! We&rsquo;ve just learned that <code>killall</code> works by opening a file in
<code>/proc</code> (wheeee!), finding what its name is, and seeing if it&rsquo;s the
same as &ldquo;firefox&rdquo;. That makes sense!</p>

<h2 id="when-are-these-tools-useful">When are these tools useful?</h2>

<p>These systems-level debugging tools are only appropriate sometimes. If
you&rsquo;re writing a graph traversal algorithm and it has a logical error,
knowing which files it opened won&rsquo;t help you at all!</p>

<p>Here are some examples of times when using systems tools might make
your life easier:</p>

<ul>
<li>Is your program running a command, but the wrong one? Look at
<code>execve</code>!</li>
<li>Your program communicates with something on a network, but some of
the information it&rsquo;s sending is wrong? It&rsquo;s probably sending it with
<code>write</code>, <code>sendto</code>, or <code>send</code>.</li>
<li>Your program writes to a file, but you don&rsquo;t know what file it&rsquo;s
writing to? Use <code>/proc</code> to see what files it has open, or look at
what it&rsquo;s <code>write</code>ing. <code>/proc</code> doesn&rsquo;t lie.</li>
</ul>

<p>At first debugging this way is confusing, but once you&rsquo;re familiar
with the tools it can actually be faster, because you don&rsquo;t have to
worry about getting the wrong information! And you feel like a WIZARD.</p>

<h2 id="learn-your-operating-system-instead-of-a-new-debugger">Learn your operating system instead of a new debugger</h2>

<p>There are all kinds of programming-language-specific debugging tools
you can use. <code>gdb</code>! <code>pry</code>! <code>pdb</code>! And you should! But you probably
switch languages more often than you switch OSes. So, learning your OS
in depth and then using it as a debugging tool is likely a better
investment of your time than learning a language-specific debugging
tool.</p>

<p>If you want to know which files a process has open, it doesn&rsquo;t matter
if that program was originally written in C++ or Python or Java or
Haskell. The <em>only way</em> for a program to open a file on Linux is with
the <code>open</code> system call. If you learn your operating system, you
acquire superpowers. You can debug programs that are binary-only and
closed source. You can use the same tools to debug no matter which
language you&rsquo;re writing.</p>

<p>And my favorite thing about these methods is that your OS won&rsquo;t lie to
you. The <strong>only way</strong> to run a program is with the <code>execve</code> system
call. There aren&rsquo;t other ways. So if you really want to know what
command got run, use <code>strace</code>. See exactly which parameters get passed
to <code>execve</code>. You&rsquo;ll know exactly what happened.</p>

<h2 id="further-reading">Further reading</h2>

<p>Try Greg Price&rsquo;s excellent blog post
<a href="https://blogs.oracle.com/ksplice/entry/strace_the_sysadmin_s_microscope">Strace &ndash; The Sysadmin&rsquo;s Microscope</a>.
I have an
<a href="/blog/categories/strace">ever-growing collection of blog posts about strace</a>,
too!</p>

<p>My favorite way to learn more, honestly, is to just strace random
programs and see what I find out. It&rsquo;s a great way to spend a rainy
Sunday afternoon! =)</p>

<p>Thanks to <a href="http://composition.al/">Lindsey Kuper</a> and
<a href="http://danluu.com">Dan Luu</a> for reading a draft of this :)</p>

<p>Have fun!</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recovering files using /proc (and spying, too!)]]></title>
    <link href="https://jvns.ca/blog/2014/03/23/recovering-files-using-slash-proc-and-other-useful-facts/"/>
    <updated>2014-03-23T11:16:24+00:00</updated>
    <id>https://jvns.ca/blog/2014/03/23/recovering-files-using-slash-proc-and-other-useful-facts/</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve had a vague idea for years that /proc was a way the Linux kernel
exposed its internals, and that I could look there to find things.</p>

<p>Then I learned this:</p>

<blockquote class="twitter-tweet" lang="en"><p>TIL!!! If you
accidentally delete a file that a process still has open, you can
recover it with cat /proc/$pid/fd/$file_descriptor. so
easy!</p>&mdash; Julia Evans (@b0rk) <a
href="https://twitter.com/b0rk/statuses/446291944575352833">March 19,
2014</a></blockquote>

<p>Suddenly it was like <code>/proc</code> was turned into a magical unicorn! I can
use it to recover my files?! ★★Amazing★★.</p>

<p>Let&rsquo;s explain why this works. When a process opens a file (including
sockets), it gets a <em>file descriptor</em> for that file, which is a number
starting at 0.</p>

<p></p>

<h3 id="file-descriptors-and-investigations-on-std-in-out-err">File descriptors and investigations on std{in,out,err}</h3>

<p>0, 1, and 2 are always the stdin, stdout, and stderr of the process.
For example, if I look at the file descriptors for a Google Chrome
process I have, I see:</p>

<pre>
$ ls /proc/4076/fd
0  10  12  14  16  18  2   21  23  26  28  3   31  34  36  38  4   41  43  5   6  72  8
1  11  13  15  17  19  20  22  25  27  29  30  32  35  37  39  40  42  44  53  7  74  9
</pre>

<p>That&rsquo;s pretty opaque! Let&rsquo;s take a closer look.</p>

<pre>
$ ls -l /proc/4076/fd/{0,1,2}
lr-x------ 1 bork bork 64 Mar 22 22:38 /proc/4076/fd/0 -> /dev/null
l-wx------ 1 bork bork 64 Mar 22 22:38 /proc/4076/fd/1 -> /dev/null
l-wx------ 1 bork bork 64 Mar 22 22:38 /proc/4076/fd/2 -> /home/bork/.xsession-errors
</pre>

<p>Neat, the numbers 0, 1, and 2 are just symbolic links! It looks like
Chrome doesn&rsquo;t have any stdin or stdout, which makes sense, but the
stderr is <code>/home/bork/.xsession-errors</code>. I didn&rsquo;t know that! It turns
out this is also a great way to find out where a process that you
didn&rsquo;t start is redirecting its output.</p>

<p>Where else do my programs redirect their stderr? Let&rsquo;s see! I looked
at everything&rsquo;s stderr, got awk to pull out just the file, and ran
<code>uniq</code> to get the counts.</p>

<pre>
$ ls -l /proc/*/fd/2 | awk '{print $11}' | sort | uniq -c
      42 /dev/null
      2 /dev/pts/0
      1 /dev/pts/1
      3 /dev/pts/2
      2 /dev/pts/3
      2 /dev/pts/4
      5 /dev/pts/5
      1 /dev/pts/7
     25 /home/bork/.xsession-errors
</pre>

<p>So mostly /dev/null, some of them are running on terminals
(<code>/dev/pts/*</code>), and the rest to <code>~/.xsession-errors</code>. No huge
surprises here.</p>

<p>What else could we use these file descriptors for? Someone on Twitter
suggested this:</p>

<blockquote class="twitter-tweet" data-conversation="none"
lang="en"><p><a href="https://twitter.com/b0rk">@b0rk</a> When I was
making my first Tarsnap backup, I used `readlink
/proc/&lt;TARSNAP&gt;/fd/7` in a loop to find out what file it was
on.</p> &mdash; Matthew Frazier (@LeafStorm) <a
href="https://twitter.com/LeafStorm/statuses/447564888198885376">March
23, 2014</a></blockquote>

<p>This works because when you open different files again and again in a
loop, it will usually end up with the same file descriptor. You could
also do the same thing by running <code>strace -etrace=open -p$TARSNAP_PID</code>
to see which files Tarsnap is opening.</p>

<p>Okay, now we know that we can use /proc to learn about our processes&rsquo;
files! What else?</p>

<h3 id="spy-on-your-processes-with-proc-pid-status">Spy on your processes with /proc/$pid/status</h3>

<p>If you look at the file <code>/proc/$pid/status</code>, you can find out all
sorts of information about your processes! You can look at this for
any process.</p>

<p>Here&rsquo;s a sample of what&rsquo;s in that file:</p>

<pre>
Name:   chrome
Groups: 4 20 24 27 30 46 104 109 124 1000 
VmPeak:   853984 kB
VmSize:   670392 kB
VmData:   323264 kB
VmExe:     96100 kB
Threads:        3
Cpus_allowed_list:      0-7
</pre>

<p>So we can see there&rsquo;s some information about the memory, its name, its
groups, its threads, and which CPUs it&rsquo;s allowed to run on.</p>

<p>But wait! We could have found out a lot of this information with <code>ps
aux</code>. How does <code>ps</code> do it? Let&rsquo;s find out!</p>

<pre>
$ strace -f -etrace=open ps aux
...
open("/proc/30219/stat", O_RDONLY)      = 6
open("/proc/30219/status", O_RDONLY)    = 6
open("/proc/30219/cmdline", O_RDONLY)   = 6
...
</pre>

<p>So <code>ps</code> gets its information from <code>/proc</code>! Neat.</p>

<h3 id="i-m-sold-what-else-is-there">I&rsquo;m sold. What else is there?!!</h3>

<p>I tweeted asking for suggestions of things to find in <code>/proc/</code>, and
someone replied linking to the
<a href="http://linux.die.net/man/5/proc">/proc man page</a>. I thought they were
trolling me, but then I clicked on it and it was actually useful!</p>

<p>A few more things I need to investigate:</p>

<ul>
<li>the <code>procps</code> and <code>sysstat</code> utilities</li>
<li>a ton of wonderful suggestions by Keegan McAllister on the
<a href="https://blogs.oracle.com/ksplice/entry/solving_problems_with_proc">Ksplice blog</a>
(including how to force a program to take stdin if it doesn&rsquo;t take
stdin)</li>
<li><code>/sys</code> replaces part of <code>/proc</code>&rsquo;s functionality.</li>
<li>Plan 9 / Inferno took this &ldquo;everything is a file&rdquo; business even more
seriously than Linux does</li>
<li><a href="https://en.wikipedia.org/wiki/Debugfs">debugfs</a> / ftrace.
<a href="http://thread.gmane.org/gmane.linux.kernel.mmc/4248/focus=4400">An example someone linked to.</a></li>
</ul>

<p>I still feel like there are concrete uses for <code>/proc/</code> that I don&rsquo;t
know about, though. What are they?</p>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Rust OS will never be finished (and it&#39;s a success!)]]></title>
    <link href="https://jvns.ca/blog/2014/03/21/my-rust-os-will-never-be-finished/"/>
    <updated>2014-03-21T07:38:59+00:00</updated>
    <id>https://jvns.ca/blog/2014/03/21/my-rust-os-will-never-be-finished/</id>
    <content type="html"><![CDATA[<p>In November/December last year, I spent 3 weeks working on a toy
operating system in Rust. (for more, see
<a href="http://jvns.ca/blog/2014/03/12/the-rust-os-story/">Writing an OS in Rust in tiny steps</a>,
and <a href="http://jvns.ca/blog/categories/kernel/">more</a>).</p>

<p>I wrote a ton of blog posts about it, and I gave a talk about the
process at Mozilla last week
(<a href="https://air.mozilla.org/rust-meetup-march-2014/">the video</a>). At
that talk, a few people asked me if I was going to finish the project.
I said no, and here&rsquo;s why.</p>

<p>There are lots of reasons for working on programming projects. Just a
few:</p>

<ul>
<li>to end up with useful code</li>
<li>to learn something</li>
<li>to explore a new concept (see: Bret Victor&rsquo;s demos)</li>
</ul>

<p>The reason I wrote an operating system in Rust wasn&rsquo;t so that I could
have an operating system written in Rust.

I already have an kernel on
my computer (Linux), and other people have already written Rust
operating systems better than I have. Any code that I write in 3 weeks
is at best a duplication of someone else&rsquo;s work, and mimicking
the state of the art 20 years ago.</p>

<p>I worked on that project to learn about how operating systems work,
and that was a huge success. I read a 20-part essay about linkers, and
learned about virtual memory, how executables are structured, how
program execution works, how system calls work, the x86 boot process,
interrupt handlers, keyboard drivers, and a ton of other things.</p>

<p>Another amazing example of a project like this is
<a href="http://twitter.com/kellabyte">@kellabyte</a>&rsquo;s
<a href="https://github.com/kellabyte/Haywire">Haywire</a>, a HTTP server in C
she wrote to learn more about writing performant code. It actually
compiles and you can benchmark it yourself, but her blog posts are
more useful to me than her code &ndash;
<a href="http://kellabyte.com/2013/08/16/hello-haywire/">Hello haywire</a>
<a href="http://kellabyte.com/2013/08/20/http-response-caching-in-haywire/">HTTP response caching in Haywire</a>,
<a href="http://kellabyte.com/2013/08/22/further-reducing-memory-allocations-and-use-of-string-functions-in-haywire/">Further reducing memory allocations and use of string functions in Haywire</a>.</p>

<p>So when people ask me why my code doesn&rsquo;t compile, it&rsquo;s because the
code is basically a trivial output of the process. The
<a href="http://jvns.ca/blog/categories/kernel/">blog posts I wrote</a> are
<em>much</em> more important, because they talk about what I learned. My code
probably won&rsquo;t be useful to you &ndash; it would be better to start with
<a href="https://github.com/charliesome/rustboot">rustboot</a> and take your own
path.</p>

<p>Not finishing your project doesn&rsquo;t mean it&rsquo;s not a success. It depends
what your goals are the for the project! I wrote an operating system
in Rust to learn, and I learned a ton. It&rsquo;s not finished, and it won&rsquo;t
be. How could it ever be? I hope to not ever finish learning.</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing an OS in Rust in tiny steps (Steps 1-5)]]></title>
    <link href="https://jvns.ca/blog/2014/03/12/the-rust-os-story/"/>
    <updated>2014-03-12T07:09:10+00:00</updated>
    <id>https://jvns.ca/blog/2014/03/12/the-rust-os-story/</id>
    <content type="html"><![CDATA[<p>I&rsquo;m giving a talk tomorrow on writing a kernel in Rust.</p>

<p>My experience of writing a kernel that it was like jumping in puddles:
it&rsquo;s a lot of fun, and there are a lot of mishaps:</p>

<p><img src="/images/puddle.gif"></p>

<p>Here are a few of the tiny steps I took. There are more, but those
will have to wait for the evening.</p>

<p></p>

<h3 id="step-1-copy-some-code-from-the-internet">Step 1: copy some code from the internet</h3>

<p>I didn&rsquo;t know what I was doing, so I didn&rsquo;t want to start from
scratch! So I started with something that already existed! Behold
<a href="https://github.com/charliesome/rustboot">rustboot</a>, a tiny 32-bit
kernel written in Rust.</p>

<p>Rustboot does only two things, but it does them well!</p>

<ol>
<li>Turn the screen red</li>
<li>Hang</li>
</ol>

<p>Of course what it actually does is a bit more complicated &ndash; there&rsquo;s</p>

<ul>
<li>a loader written in assembly</li>
<li>a Makefile that lets you run it with <code>qemu</code></li>
<li>Some Rust code to clear the screen</li>
</ul>

<p>Here&rsquo;s the code that clears the screen:</p>

<pre><code>unsafe fn clear_screen(background: Color) {
    range(0, 80*25, |i| {
        *((0xb8000 + i * 2) as *mut u16) = (background as u16) &lt;&lt; 12;
    });
}
</code></pre>

<p>What does this mean? The key part here is that the address of the VGA
buffer is <code>0xb8000</code>, so we&rsquo;re setting some bytes there. And there&rsquo;s a
loop.</p>

<h3 id="step-2-turn-the-screen-blue-instead">Step 2: Turn the screen blue instead.</h3>

<p>The first thing I did was:</p>

<ol>
<li>Make sure I could run <code>rustboot</code>.</li>
<li>Change &lsquo;red&rsquo; to &lsquo;blue&rsquo; and run it again</li>
</ol>

<p>This sounds silly, but psychologically it&rsquo;s an important step! It
forced me to look at the code and understand how it worked, and it was
really exciting that it worked right away.</p>

<h3 id="step-3-start-writing-i-o-functions">Step 3: Start writing I/O functions</h3>

<p>The next obvious step now that I had a blue screen was to try to write
a <code>print</code> function.</p>

<p>Here&rsquo;s what it looked like!</p>

<pre><code>pub fn putchar(x: u16, y: u16, c: u8) {
    let idx : uint =  (y * VGA_WIDTH * 2 + x * 2) as uint;
    unsafe {
        *((VGA_ADDRESS + idx) as *mut u16) = make_vgaentry(c, fg_color, bg_color);
    }
}
</code></pre>

<p>I didn&rsquo;t explain the <code>unsafe</code> block before. Everything inside
<code>unsafe{}</code> is <em>unsafe</em> code. This particular code is unsafe because it
accesses a memory address directly. Wrapping it in an unsafe block
tells Rust &ldquo;okay, I checked and I promise this code is actually doing
the right thing and won&rsquo;t blow anything up&rdquo;.</p>

<p>We can also look at <code>make_vgaentry</code>:</p>

<pre><code>fn make_vgaentry(c: u8, fg: Color, bg: Color) -&gt; u16 {
    let color = fg as u16 | (bg as u16 &lt;&lt; 4);
    return c as u16 | (color &lt;&lt; 8);
}
</code></pre>

<p>In the VGA buffer, each character is represented by 2 bytes (so a
<code>u16</code>). The lower 8 bits are the ASCII character, and the upper 8 bits
are the foreground and background colour (4 bits each). <code>Color</code> here
is an enum so that I can refer to Red or Green directly.</p>

<p>I found this part pretty approachable and it didn&rsquo;t take too long.
Which isn&rsquo;t to say that I didn&rsquo;t have problems! I had SO MANY
PROBLEMS. Most of my problems were to do with arrays and string and
iterating over strings. Here&rsquo;s some code that caused me much pain:</p>

<pre><code>pub fn write(s: &amp;str) {
    let bytes : &amp;[u8] = as_bytes(s);
    for b in super::core::slice::iter(bytes) {
        putc(*b);
    }
}
</code></pre>

<p>This code looks simple! It is a lie.
Friends. Here were some questions that I needed to ask to write this code.</p>

<ul>
<li>How do I turn a string into a byte array? (<code>as_bytes()</code>)</li>
<li>What is the type of a byte array? (<code>&amp;[u8]</code>)</li>
<li>How do I iterate over a byte array? (+ &ldquo;it still doesn&rsquo;t work!&rdquo;, 4 times)</li>
</ul>

<p>Also, what is this <code>super::core::slice::iter</code> business? This brings us
to a fairly long digression, and an important point</p>

<h3 id="why-you-can-t-write-a-kernel-in-python">Why you can&rsquo;t write a kernel in Python</h3>

<p>So you want to write an operating system, let&rsquo;s say for x86. You need
to write this in a programming language!</p>

<p>Can you write your operating system in Python (using CPython, say)?
You cannot. This is not being curmudgeonly! It is actually just not
possible.</p>

<p>What happens when you write <code>print &quot;Hello!&quot;</code> in Python?</p>

<p>Well, many things happen. But the <em>last</em> thing that happens is that
the CPython interpreter will do something like <code>printf(&quot;Hello&quot;)</code>. And
you might think, well, maybe I could link against the code for
<code>printf</code> somehow!</p>

<p>But what <code>printf</code> does is it calls the <code>write()</code> system call. The
<code>write()</code> system call is implemented IN YOUR KERNEL.</p>

<p>OH WAIT YOU DON&rsquo;T HAVE A KERNEL YET. YOU ARE WRITING ONE.</p>

<p>This also means that you can&rsquo;t write a kernel as a &ldquo;normal&rdquo; C program
which includes C libraries. Any C libraries. All C libraries for Linux
are built on top of some version of <code>libc</code>, which makes calls to the
Linux kernel! So if you&rsquo;re <em>writing</em> a kernel, this doesn&rsquo;t work.</p>

<h3 id="why-you-can-write-a-kernel-in-rust">Why you <em>can</em> write a kernel in Rust</h3>

<p>Writing Rust code has many of the same problems, of course! By
default, if you compile a Rust program with a print statement, it will
call your kernel&rsquo;s equivalent to <code>write</code>.</p>

<p>But! Unlike with Python, you can put <code>#[no_std]</code> at the beginning of
your Rust program.</p>

<p>You lose a lot! You can no longer</p>

<ul>
<li>allocate memory</li>
<li>do threading</li>
<li>print anything</li>
<li>many many more things</li>
</ul>

<p>It&rsquo;s still totally fine to define functions and make calculations,
though. And you can of course define your own functions to allocate
memory.</p>

<p>You also lose things like Rust&rsquo;s iterators, which is sad!</p>

<h3 id="rust-core">rust-core</h3>

<p><a href="https://github.com/thestinger/rust-core">rust-core</a> is &ldquo;a standard
library for Rust with freestanding support&rdquo;. What this means is that
if you&rsquo;re writing an OS, <code>rust-core</code> will provide you with all kinds
of helpful data structures and functions that you lost when you wrote
<code>#[no_std]</code>.</p>

<p>I found using this library pretty confusing, but the author hangs out
in IRC all the time and was really friendly to me, so it wasn&rsquo;t a huge
problem.</p>

<p>So back to <code>super::core::slice::iter</code>! This says &ldquo;iterate over this
using an iteration function from <code>rust-core</code>&ldquo;</p>

<h3 id="step-4-keyboard-interrupts">Step 4: keyboard interrupts!</h3>

<p>So it took me a few days to learn how to print because I needed
to learn about freestanding mode and get confused about rust-core and
at the same time I didn&rsquo;t really understand Rust&rsquo;s types very well.</p>

<p>Once that was done, I wanted to be able to do the following:</p>

<ol>
<li>Press a key (&lsquo;j&rsquo; for example)</li>
<li>Have that letter appear on the screen.</li>
</ol>

<p>I thought this wouldn&rsquo;t be too hard. I was pretty wrong.</p>

<p>I wrote about what went wrong in
<a href="http://jvns.ca/blog/2013/12/04/day-37-how-a-keyboard-works/">After 5 days, my OS doesn&rsquo;t crash when I press a key</a>.</p>

<p>It lists all my traumas in excruciating detail and I won&rsquo;t repeat them
here. Go read it. It&rsquo;s kinda worth it. I&rsquo;ll wait.</p>

<h3 id="step-5-malloc">Step 5: malloc!</h3>

<p>After I&rsquo;d done that, I thought it might be fun to be able to allocate
memory.</p>

<p>You may be surprised at this point. We have printed strings! We have
made our keyboard work! Didn&rsquo;t we need to allocate memory? Isn&rsquo;t
that&hellip; <em>important</em>?</p>

<p>It turns out that you can get away without doing it pretty easily!
Rust would automatically create variables on the stack for me, so I
could use local variables. And for anything else I could use global
variables, and the space for those was laid out at compile time.</p>

<p>But allocating memory seemed like a fun exercise. To allocate
something on the heap in Rust, you can do</p>

<p><code>let a = ~2</code></p>

<p>This creates a pointer to a <code>2</code> on the heap. Of course, we talked
before about how there is no malloc! So I wrote one, and then made
sure that Rust knew about it.</p>

<p>You can see the <code>malloc</code> function I wrote in
<a href="http://jvns.ca/blog/2013/12/10/day-39-i-wrote-a-malloc/">Writing malloc wrong, for fun</a></p>

<p>The hardest parts of this were not writing the function, but</p>

<ul>
<li>getting the type right</li>
<li>Understanding how Rust&rsquo;s language features can be turned on and off.</li>
</ul>

<p>WHAT DO YOU MEAN TURNED ON AND OFF, you may ask!</p>

<p>So in <code>rust-core</code>, if you go to
<a href="https://github.com/thestinger/rust-core/blob/85c28bb64ec093aff9e3f81110200793c6291467/core/heap.rs#L32">heap.rs</a>,
you&rsquo;ll see this code:</p>

<pre><code>#[lang = &quot;exchange_malloc&quot;]
pub unsafe fn alloc(size: uint) -&gt; *mut u8 {
    if size == 0 {
        0 as *mut u8
    } else {
        let ptr = malloc(size);
        if ptr == 0 as *mut u8 {
            out_of_memory()
        }
        ptr
    }
}
</code></pre>

<p>This weird-looking <code>#[lang = &quot;exchange_malloc&quot;]</code> bit means &ldquo;Code like
<code>let x = ~2</code> is now allowed to work&rdquo;. It requires there to be an
implementation of <code>malloc</code>, which I wrote. It also needs implements of
<code>realloc</code> and <code>free</code>, but I left those blank :)</p>

<p>Before seeing that, Rust would not compile code that allocated memory.</p>

<p>I think this language feature gating is really cool: it means that you
can write Rust programs that can allocate memory, but not do
threading. Or that can do hardly anything at all!</p>

<p>I need to get up now.</p>

<p><strong>Next up:</strong> running problems! AND SOMETHING IS ERASING MY PROGRAM WHILE
IT IS RUNNING.</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging shared library problems with strace]]></title>
    <link href="https://jvns.ca/blog/2014/03/10/debugging-shared-library-problems-with-strace/"/>
    <updated>2014-03-10T20:46:10+00:00</updated>
    <id>https://jvns.ca/blog/2014/03/10/debugging-shared-library-problems-with-strace/</id>
    <content type="html"><![CDATA[<p>It&rsquo;s official. I have a love affair with strace.</p>

<p>So strace is this Linux command that shows you what system calls a program
calls.</p>

<p>This doesn&rsquo;t sound so useful until you find out that it is useful FOR
EVERYTHING. Seriously. strace is like an immersion blender. I use strace more
than my immersion blender.</p>

<p></p>

<p>Previously we have used strace to
<a href="http://jvns.ca/blog/2013/12/22/fun-with-strace/">find out how killall works</a>,
<a href="http://jvns.ca/blog/2014/02/17/spying-on-ssh-with-strace/">spy on ssh</a>,
<a href="http://jvns.ca/blog/2014/02/26/using-strace-to-avoid-reading-ruby-code/">avoid reading Ruby code</a>, and
<a href="http://jvns.ca/blog/2014/02/27/more-practical-uses-for-strace/">more</a>.</p>

<p>So today I had was trying to install the
<a href="https://github.com/minad/iruby/">IRuby notebook</a>. But my version of libzmq was wrong! So I upgraded it. But it was STILL WRONG. Why? WHY?</p>

<p>So I thought, I will get strace to tell me which shared libraries are being loaded! strace will never lie to me. Here&rsquo;s how to do that:</p>

<pre><code>strace -f -o /tmp/iruby_problems ~/clones/iruby/bin/iruby notebook
grep libzmq.so /tmp/iruby_problems | grep -v ENOENT
</code></pre>

<p>The <code>grep -v ENOENT</code> is because it looks everywhere in my LD_LIBRARY_PATH so it
fails to find libzmq a bunch of times. This reveals the following two system
calls:</p>

<pre><code>28863 open(&quot;/opt/anaconda/lib/python2.7/site-packages/zmq/utils/../../../../libzmq.so.3&quot;, O_RDONLY|O_CLOEXEC) = 9
28910 open(&quot;/usr/lib/libzmq.so&quot;, O_RDONLY|O_CLOEXEC) = 9
</code></pre>

<p>AH HA. The first libzmq is the right version (<code>libzmq.so.3</code>), but the second one is all wrong! It is <code>libzmq1</code> and it is a disaster and a disgrace. I did <code>sudo apt-get remove libzmq1</code> and the offending <code>libzmq</code> was banished from my system.</p>

<p>Thanks, strace :)</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More practical uses for strace!]]></title>
    <link href="https://jvns.ca/blog/2014/02/27/more-practical-uses-for-strace/"/>
    <updated>2014-02-27T07:25:36+00:00</updated>
    <id>https://jvns.ca/blog/2014/02/27/more-practical-uses-for-strace/</id>
    <content type="html"><![CDATA[<p>In yesterday&rsquo;s blog post on
<a href="http://jvns.ca/blog/2014/02/26/using-strace-to-avoid-reading-ruby-code/">using strace to avoid reading Ruby code</a>
I asked the Internet for some more suggestions of practical uses for
strace.</p>

<p>There were so many excellent suggestions that I couldn&rsquo;t not share!</p>

<p><a href="http://twitter.com/gazoombo">Mike English</a> pointed me to this
<em>wonderful</em>
blog post<br />
<a href="http://spin.atomicobject.com/2013/08/19/debug-ruby-processes/">Tools for Debugging Running Ruby Processes</a>
he wrote about using strace, lsof, and gdb to debug a running Ruby
processes. He remarks that some of the things are like open-heart
surgery &ndash; you can go into a running Ruby process and execute code
using gdb, but you might kill the process. Super cool and definitely
worth a read.</p>

<p>Some more great suggestions of what to do with strace:</p>

<p></p>

<p>Look for the &lsquo;open&rsquo; system call!</p>

<blockquote class="twitter-tweet" lang="en"><p><a
href="https://twitter.com/mjdominus">@mjdominus</a> <a
href="https://twitter.com/b0rk">@b0rk</a> Also invaluable when
sandboxing programs and trying to figure out where they are loading
shared libraries from.</p>&mdash; Eiríkr Åsheim (@d6) <a
href="https://twitter.com/d6/statuses/438904114597347329">February 27,
2014</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none"
lang="en"><p><a href="https://twitter.com/b0rk">@b0rk</a> While
looking at git performance, I&#39;ve used strace -c as well as <a
href="https://twitter.com/pgbovine">@pgbovine</a>&#39;s
strace-plus.</p>&mdash; David Turner (@NovalisDMT) <a
href="https://twitter.com/NovalisDMT/statuses/438901005108133888">February
27, 2014</a></blockquote>

<p>A suggestion to also use ltrace:</p>

<blockquote class="twitter-tweet" data-conversation="none"
lang="en"><p><a href="https://twitter.com/b0rk">@b0rk</a> all I know
is that I usually start with strace, get annoyed with it, then
remember to use ltrace instead. :-)</p>&mdash; Brian Mastenbrook
(@bmastenbrook) <a
href="https://twitter.com/bmastenbrook/statuses/438878838257250305">February
27, 2014</a></blockquote>

<p><blockquote class="twitter-tweet" data-conversation="none"
lang="en"><p><a href="https://twitter.com/b0rk">@b0rk</a> check out
syscall tracing on Linux, it&#39;s like strace for the whole system,
handy if you want to know which process is doing something.</p>&mdash;
Michael Ellerman (@michaelellerman) <a
href="https://twitter.com/michaelellerman/statuses/438994429219586051">February
27, 2014</a></blockquote> <script async
src="//platform.twitter.com/widgets.js" charset="utf-8"></script> I
didn&rsquo;t know syscall tracing was a thing! This seems very worthy of
investigation.</p>

<script async src="//platform.twitter.com/widgets.js"
charset="utf-8"></script>

<p>Here are some
<a href="http://price.mit.edu/tracing-w2014/#12">slides by Greg Price</a> with a
bunch of great suggestions for fixing various problems, as well as his
blog post
<a href="https://blogs.oracle.com/ksplice/entry/strace_the_sysadmin_s_microscope">Strace - The Sysadmin&rsquo;s Microscope</a>
from the wonderful ksplice blog.</p>

<p>Alex Clemmer wrote a super cool post on using dtruss (strace, but for
OS X/BSD) to try to better understand concurrency primitives:
<a href="http://blog.nullspace.io/day-266.html">The unfamiliar world of OS X syscalls</a>.</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using strace to avoid reading Ruby code]]></title>
    <link href="https://jvns.ca/blog/2014/02/26/using-strace-to-avoid-reading-ruby-code/"/>
    <updated>2014-02-26T18:49:06+00:00</updated>
    <id>https://jvns.ca/blog/2014/02/26/using-strace-to-avoid-reading-ruby-code/</id>
    <content type="html"><![CDATA[<p><small>
This is the start of a new category! I just started at
<a href="http://stripe.com">Stripe</a> yesterday, so this is in the
<a href="/blog/categories/stripe">things-I-am-learning-at-Stripe category</a>.
Yay!
</small></p>

<p>Yesterday I was getting set up, and we were having a problem with an
internal tool written in Ruby that was sshing somewhere. So we wanted
to know exactly what ssh command it was running. The normal way I&rsquo;d
think about doing this is by, well, reading the code. But that takes
time!</p>

<p></p>

<p>So! My new favorite thing in life is strace (as evidenced by these
<a href="http://jvns.ca/blog/2013/12/22/fun-with-strace/">two</a>
<a href="http://jvns.ca/blog/2014/02/17/spying-on-ssh-with-strace/">posts</a>)
(when all you have is a hammer&hellip;). But I wasn&rsquo;t sure that we could
use strace to figure out the ssh command.</p>

<p>But then <a href="https://twitter.com/ebroder">Evan</a> did this (or something equivalent):</p>

<p><code>strace -f -e trace=execve [the ruby command]</code></p>

<p>This looks at all the system calls that the command runs, filters out
everything that isn&rsquo;t executing a command, and also looks in all the
child processes. Grepping for ssh spat out the exact ssh command that
it was running!</p>

<p>The looking-in-all-child-processes part (<code>-f</code>) is important because it
started some subprocesses.</p>

<p>This is super fun because what I&rsquo;d usually do is go read the code to
try and figure out what it&rsquo;s doing, and reading code is hard! strace
is easy!</p>

<p>Also it&rsquo;s a great example of incidental/accidental learning. I like
working with people who know more (and different!) things than I do :)</p>

<p>I&rsquo;m trying to put together more examples of when understanding how
system calls work is useful in everyday non-kernel-hacking
programming. If you have suggestions, tell me on Twitter! I&rsquo;m
<a href="http://twitter.com/b0rk">@b0rk</a>. (or by email!)</p>

<p>(<strong>edit</strong>: <a href="http://web.mit.edu/price/">Greg Price</a> suggested using
<code>strace -e process</code> instead of <code>strace -e trace=execve</code>. It&rsquo;s shorter,
and it also shows you other process-related system calls.)</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[4 paths to being a kernel hacker]]></title>
    <link href="https://jvns.ca/blog/2014/01/04/4-paths-to-being-a-kernel-hacker/"/>
    <updated>2014-01-04T00:00:00+00:00</updated>
    <id>https://jvns.ca/blog/2014/01/04/4-paths-to-being-a-kernel-hacker/</id>
    <content type="html"><![CDATA[<p>(this is me continuing work on my <a href="http://2014.cusec.net/">CUSEC</a> talk
about why the kernel isn&rsquo;t scary)</p>

<p>I once tried asking for advice about how to get started with kernel
programming, and was basically told:</p>

<ol>
<li>If you don&rsquo;t <em>need</em> to understand the kernel for your work, why
would you try?</li>
<li>You should subscribe to the
<a href="https://lkml.org/">Linux kernel mailing list</a> and just try really
hard to understand.</li>
<li>If you&rsquo;re not writing code that&rsquo;s meant to be in the main Linux
kernel, you&rsquo;re wasting your time.</li>
</ol>

<p>This was really, really, really not helpful to me. So here are a few
possible strategies for learning about how operating systems and the
Linux kernel work on your own terms, while having fun. I still only
know a few things, but I know more than I did before :)
</p>

<p>For most of these paths, you&rsquo;ll need to understand some C, and a bit
of assembly (at least enough to copy and paste). I&rsquo;d written a few
small C programs, and took a course in assembly that I&rsquo;d almost
entirely forgotten.</p>

<h3 id="path-1-write-your-own-os">Path 1: Write your own OS</h3>

<p>This might seem to be a pretty frightening path. But actually it&rsquo;s
not! I started with
<a href="https://github.com/charliesome/rustboot">rustboot</a>, which, crucially,
<em>already worked and did things</em>. Then I could do simple things like
making the screen <em>blue</em> instead of red, printing characters to the
screen, and move on to trying to get keyboard interrupts to work.</p>

<p><a href="http://mikeos.berlios.de/write-your-own-os.html">MikeOS</a> also looks
like another fun thing to start with. Remember that your operating
system doesn&rsquo;t have to be big and professional &ndash; if you make it turn
the screen purple instead of red and then maybe make it print it a
limerick, you&rsquo;ve already won.</p>

<p>You&rsquo;ll definitely want to use an emulator like
<a href="http://wiki.qemu.org/Main_Page">qemu</a> to run your OS in. The
<a href="http://wiki.osdev.org/Main_Page">OSDev wiki</a> is also a useful
place &ndash; they have FAQs for a lot of the problems you&rsquo;ll run into
along the way.</p>

<h3 id="path-2-write-some-kernel-modules">Path 2: Write some kernel modules!</h3>

<p>If you&rsquo;re already running Linux, writing a kernel module that doesn&rsquo;t
do anything is pretty easy.</p>

<p>Here&rsquo;s
<a href="https://github.com/jvns/kernel-module-fun/blob/master/hello.c">the source for a module</a>
that prints &ldquo;Hello, hacker school!&rdquo; to the kernel log. It&rsquo;s 18 lines
of code. Basically you just register an init and a cleanup function
and you&rsquo;re done. I don&rsquo;t really understand what the <code>__init</code> AND
<code>__exit</code> macros do, but I can use them!</p>

<p>Writing a kernel module that does do something is harder. I did this
by deciding on a Thing to do (for example, print a message for every
packet that comes through the kernel), and then read
some <a href="http://kernelnewbies.org/">Kernel Newbies</a>, googled a lot, and
copied and pasted a lot of code to figure out how to do it. There are
a couple of examples of kernel modules I wrote in this
<a href="https://github.com/jvns/kernel-module-fun">kernel-module-fun</a>
repository.</p>

<h3 id="path-3-do-a-linux-kernel-internship">Path 3: Do a Linux kernel internship!</h3>

<p>The Linux kernel participates in the
<a href="https://wiki.gnome.org/OutreachProgramForWomen">GNOME Outreach Program for Women</a>.
This is amazing and fantastic and delightful. What it means is that if
you&rsquo;re a woman and want to spend 3 months working on the kernel, you
can get involved in kernel development without any prior experience,
and get paid a bit ($5000). Here&rsquo;s
<a href="http://kernelnewbies.org/OPWIntro">the Kernel Newbies page explaining how it works</a>.</p>

<p>It&rsquo;s worth applying if you&rsquo;re at all interested &ndash; you get to format a
patch for the kernel and it&rsquo;s fun.
<a href="http://sarah.thesharps.us/">Sarah Sharp</a>, a Linux kernel developer,
coordinates this program and she is pretty inspiring. You should read
her
<a href="http://sarah.thesharps.us/2013/05/23/%EF%BB%BF%EF%BB%BFopw-update/">blog post about how 137 patches got accepted into the kernel during the first round</a>.
These patches could be yours! Look at the
<a href="http://kernelnewbies.org/OPWApply">application instructions</a>!</p>

<p>If you&rsquo;re not a woman, Google Summer of Code is similar.</p>

<h3 id="path-4-read-some-kernel-code">Path 4: Read some kernel code</h3>

<p>This sounds like terrible advice &ndash; &ldquo;Want to understand how the kernel
works? Read the source, silly!&rdquo;</p>

<p>But it&rsquo;s actually kind of fun! You won&rsquo;t understand everything. I felt
kind of dumb for not understanding things, but then every single
person I talked to was like &ldquo;yeah, it&rsquo;s the Linux kernel, of course!&rdquo;.</p>

<p>My friend Dave recently pointed me to <a href="http://lxr.linux.no/">LXR</a>,
where you can read the kernel source and it provides lots of helpful
cross-referencing links. For example, if you wanted to understand the
<code>chmod</code> system call, you can go look at
<a href="http://lxr.linux.no/linux+v3.12.6/fs/open.c#L464">the chmod_common definition</a>
in the Linux kernel! <a href="http://livegrep.com/search/linux">livegrep.com</a>
is also really nice for this.</p>

<p>Here&rsquo;s the source for <code>chmod_common</code>, with some comments from me:</p>

<pre><code>static int chmod_common(struct path *path, umode_t mode)
{
    struct inode *inode = path-&gt;dentry-&gt;d_inode;
    struct iattr newattrs;
    int error;

    // No idea what this does
    error = mnt_want_write(path-&gt;mnt);
    if (error)
        return error;

    // Mutexes! Prevent race conditions! =D
    mutex_lock(&amp;inode-&gt;i_mutex);

    // Check for permission to use chmod, I guess.
    error = security_path_chmod(path, mode);
    if (error)
        goto out_unlock;
    // I guess this changes the mode!
    newattrs.ia_mode = (mode &amp; S_IALLUGO) | (inode-&gt;i_mode &amp; ~S_IALLUGO);
    newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
    error = notify_change(path-&gt;dentry, &amp;newattrs);
out_unlock:
    mutex_unlock(&amp;inode-&gt;i_mutex); // We're done, so the mutex is over!
    mnt_drop_write(path-&gt;mnt); // ???
    return error;
}
</code></pre>

<p>I find this is a fun time and helps demystify the kernel for me. Most
of the code I read I find pretty opaque, but some of it (like this
chmod code) is a little bit understandable.</p>

<p>To summarize a few links:</p>

<ul>
<li><a href="http://web.mit.edu/jesstess/www/">Jessica McKellar</a>&rsquo;s blog posts on
the <a href="https://blogs.oracle.com/ksplice/">Ksplice blog</a></li>
<li><a href="http://lwn.net/Kernel/LDD3/">Linux Device Drivers</a> describes itself
like this. I&rsquo;ve found it somewhat useful.
&gt; &ldquo;This book teaches you how to write your own drivers and how to hack around in related parts of the kernel.&rdquo;</li>
<li>The <a href="http://wiki.osdev.org/Main_Page">OSDev wiki</a> is great if you&rsquo;re
writing an OS.</li>
<li><a href="http://kernelnewbies.org/">Kernel Newbies</a> has some resources for
starting kernel developers. I didn&rsquo;t have good experiences in the
IRC channel, though.</li>
<li><a href="http://sarah.thesharps.us/">Sarah Sharp</a> is a kernel developer and
runs the Linux kernel outreach and is amazing.</li>
<li><a href="https://encrypted.google.com/#q=site:lwn.net+%22this+article+was+contributed+by+valerie%22">Valerie Aurora&rsquo;s posts on LWN.net</a></li>
</ul>

<p>I&rsquo;d also love to hear from you. If you&rsquo;d done kernel work, how did you
get started with kernel hacking? If you haven&rsquo;t, which of these paths
sounds most approachable to you?</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some things my kernel can&#39;t do]]></title>
    <link href="https://jvns.ca/blog/2014/01/03/what-my-kernel-doesnt-do/"/>
    <updated>2014-01-03T00:00:00+00:00</updated>
    <id>https://jvns.ca/blog/2014/01/03/what-my-kernel-doesnt-do/</id>
    <content type="html"><![CDATA[<p>I&rsquo;m working on a talk for <a href="http://2014.cusec.net/">CUSEC</a> about how
kernel programming is something that normal humans can do (albeit with
some pain and suffering).</p>

<p>Most people will be pretty unfamiliar with what a kernel is or does.
I&rsquo;m thinking of explaining it in terms of the kernel I wrote at Hacker
School, and what it can&rsquo;t do.</p>

<p>Kernel programming has become a lot more concrete to me &ndash; I now
totally feel like I could write a production OS if I were given some
hardware, 20 years and an army of volunteers.</p>

<p>So here are some pretty &ldquo;basic&rdquo; things that my kernel can&rsquo;t do. I&rsquo;m
not trying to give an exhaustive list here, but a flavor for what&rsquo;s
involved.</p>

<p></p>

<p>The idea is that once you know what a kernel does, you can pick a
Thing and a Kernel, and then dive into it and ask &ldquo;okay, what <em>is</em> the
Linux kernel&rsquo;s system for tracking processes?&ldquo;. Then you can find this
page
<a href="http://www.tldp.org/LDP/lki/lki-2.html">about the process table in Linux 2.4</a>,
read some of it, and it&rsquo;s probably different in the 3.x kernel, but
now you know more.</p>

<ul>
<li>Communicate with the hard drive

<ul>
<li>Even if it could, it doesn&rsquo;t understand any filesystems</li>
</ul></li>
<li>Communicate with the network card to connect to the Internet

<ul>
<li>Even if it could, it doesn&rsquo;t understand any network protocols like
TCP/IP</li>
</ul></li>
<li>Get out of text-only mode to display graphics</li>
<li>Run programs securely, so that they can&rsquo;t overwrite each others&rsquo;
memory</li>
<li>Run more than one program at a time (&ldquo;scheduling&rdquo;)</li>
<li>Know what time it is</li>
<li>Allow a process to sleep for a fixed amount of time</li>
<li>Put the computer to sleep / turn off the computer</li>
</ul>

<p>Some higher-level things that depend on those:</p>

<ul>
<li>Have a system for tracking processes</li>
<li>Have a way to manage processes (like signals)</li>
<li>File permissions</li>
<li>Provide a way for user programs to interact with hardware (like
<code>/dev/*</code>)</li>
</ul>

<p>These are all pretty approachable concepts (I think). I think I&rsquo;m not
going to talk about virtual memory because I don&rsquo;t know if I can
explain it well.</p>

<p>That&rsquo;s a pretty long list. What <em>can</em> my kernel do?</p>

<ul>
<li><a href="http://jvns.ca/blog/2013/11/29/writing-an-os-using-rustboot-and-rust-core/">Print to the screen</a></li>
<li><a href="http://jvns.ca/blog/2013/12/04/day-37-how-a-keyboard-works/">Understand keyboard inputs</a></li>
<li><a href="http://jvns.ca/blog/2013/12/19/day-45-reading-elf-headers/">Run programs, almost</a>
(this isn&rsquo;t working yet, but I think I&rsquo;m not too far away)</li>
</ul>

<p>So not much :)</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding how killall works using strace]]></title>
    <link href="https://jvns.ca/blog/2013/12/22/fun-with-strace/"/>
    <updated>2013-12-22T00:00:00+00:00</updated>
    <id>https://jvns.ca/blog/2013/12/22/fun-with-strace/</id>
    <content type="html"><![CDATA[<p>Right now I&rsquo;m on a million-hour train ride from New York to Montreal.
So I&rsquo;m looking at the output of <code>strace</code> because, uh, <code>strace</code> is
cool, and it is teaching me some things about how the command line
tools I
use all the time work.</p>

<p>What <code>strace</code> does is capture every single system call that gets
called when executing a program. System calls are the interface
between userspace programs and the kernel, so looking at the output
from <code>strace</code> is a fun way to understand how Linux works, and what&rsquo;s
really involved in running a program.</p>

<p>For example! <code>killall</code>! I ran</p>

<p><code>strace killall ruby1.9.1 2&gt; killall-log</code>.</p>

<p>This starts with</p>

<pre><code>execve(&quot;/usr/bin/killall&quot;, [&quot;killall&quot;, &quot;ruby1.9.1&quot;], [/* 48 vars */]) = 0
</code></pre>

<p>Every time you run a program, <code>execve</code> gets called to start, so
<code>execve</code> will always be the first line.</p>

<p>Then this happens A WHOLE BUNCH OF TIMES:</p>

<pre><code>open(&quot;/proc/4526/stat&quot;, O_RDONLY)       = 3
fstat(3, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7febbb269000
read(3, &quot;4526 (chrome) S 4521 2607 2607 0&quot;..., 1024) = 374
close(3)                                = 0
munmap(0x7febbb269000, 4096)            = 0
</code></pre>

<p>with different PIDs.</p>

<p>What&rsquo;s going on here is that it goes through every PID. To find the
PIDs, it opens the <code>/proc</code> directory. There&rsquo;s a directory in <code>/proc</code>
for each PID.</p>

<pre><code>bork@kiwi ~/w/homepage&gt; ls /proc
1      1495   2408   2780   3278  8065         fb
10006  1498   2409   2782   3281  8066         filesystems
10152  1500   2410   2795   3283  8068         fs
10158  1504   2411   28     3317  8069         interrupts
1021   1513   2412   2802   35    8070         iomem
</code></pre>

<p>The system call that does this is:</p>

<p><code>openat(AT_FDCWD, &quot;/proc&quot;, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC) = 3</code></p>

<p>Once it&rsquo;s done that, then it iterates through all the PIDs, opens
<code>/proc/$PID/stat</code>, and checks to see if the process has the right
name. The kernel isn&rsquo;t involved in seeing whether or not the process
has the right name, so we don&rsquo;t see that in the <code>strace</code> output.</p>

<p>Once it finds a PID that it wants to kill, it runs something like</p>

<pre><code>kill(11510, SIGTERM)
</code></pre>

<p>to kill it. SIGTERM isn&rsquo;t a very serious killing-y signal &ndash; it&rsquo;s
signal 15, and processes can ignore it or save their state before they
stop. If you run <code>killall -9</code>, it will sent <code>SIGKILL</code> to all the
matching processes and it will kill them dead.</p>

<p>This is really neat! I never thought of <code>killall</code> as having to do an
exhaustive search through all PIDs before, but it makes sense.</p>

<p>After all of that, if there was something to kill, the only thing left
is <code>exit_group(0)</code>. <code>man 2 exit_group</code> tells me that this exits all
threads in a process, and that this system call is called at the end
.of every process</p>

<p>If we run <code>killall blah</code>, and there was no <code>&quot;blah&quot;</code> process to kill,
instead we see:</p>

<pre><code>write(2, &quot;blah: no process found\n&quot;, 23blah: no process found) = 23
exit_group(0) 
</code></pre>

<p>because it needs to write &ldquo;no process found&rdquo; to stderr.</p>

<p><strong>Edit:</strong></p>

<p>I have learned a couple of new things, from people&rsquo;s responses to this
post!</p>

<p>If you want to see the library calls instead of the system calls, and
want to see where it does the string comparisons, you can use
<code>ltrace</code>!</p>

<p>For <code>killall</code>, finding <code>python3</code> and killing it looks like:</p>

<pre><code>__asprintf_chk(0x7fff195b6988, 1, 0x403fd9, 15499, 0x7f31d919e700) = 16
fopen(&quot;/proc/15499/stat&quot;, &quot;r&quot;)              = 0x208f8f0
free(0x0208f8d0)                            = &lt;void&gt;
fscanf(0x208f8f0, 0x403fe7, 0x7fff195b71b0, 0x7f31d8fa5728, 0) = 1
fclose(0x208f8f0)                           = 0
strcmp(&quot;python3&quot;, &quot;python3&quot;)                = 0
kill(15499, 15)                             = 0
</code></pre>

<p>And you can attach <code>strace</code> or <code>ptrace</code> to an already-running process
to see what it&rsquo;s up to. <a href="https://twitter.com/zbrdge/">@zbrdge</a> said
that he sometimes uses it to see which files Apache is accessing
during a HTTP request.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 45: I now have Rust code for executing executables!]]></title>
    <link href="https://jvns.ca/blog/2013/12/19/day-45-reading-elf-headers/"/>
    <updated>2013-12-19T00:00:00+00:00</updated>
    <id>https://jvns.ca/blog/2013/12/19/day-45-reading-elf-headers/</id>
    <content type="html"><![CDATA[<p>So I&rsquo;m working on writing a kernel in Rust, and I wanted to be able to
run executables because THAT WOULD BE COOL. Now I have the beginnings
of this working!</p>

<p>I posted about my confusion about how to run programs
<a href="http://jvns.ca/blog/2013/12/13/day-42-how-to-run-an-elf-executable-i-dont-know/">a few days ago</a>.
Then <a href="https://twitter.com/graydon_moz">Graydon Hoare</a> sent me a super
helpful email answering all my questions, and gave me an example
minimal program to use (better than &ldquo;Hello world&rdquo;). The best. One of
my favourite things about this blog is when delightful people comment
or email and answer my questions</p>

<p>This is really useful because my statically compiled Hello World
program takes up 800k, which is huge. The example program Graydon sent
me is 897 bytes compiled, so about 1000 times smaller!</p>

<p>You can compile it like this:</p>

<pre><code>$ cat &gt;static.c
int _start() {
  asm(
      &quot;mov $127,%ebx\n&quot; /* exit code        */
      &quot;mov $1,%eax\n&quot;   /* syscall #1, exit */
      &quot;int $0x80\n&quot;     /* invoke syscall   */
      );
}
^D

$ cc -m32 -static -nostdlib static.c
$ ./a.out
$ echo $?
127
</code></pre>

<p>This is super great, because it means that I can understand the whole
program and it doesn&rsquo;t have a bunch of glibc/Linux stuff compiled into
it. The only OS-specific thing here is the <code>int 80</code> interrupt, which
I&rsquo;ll need to implement. I could also make up my own convention for
system calls, but that seems unnecessary.</p>

<p>So what I need to do is</p>

<ol>
<li>Implement the <code>exit()</code> system call</li>
<li>Read the ELF header</li>
<li>Read the segment headers</li>
<li>Find out

<ol>
<li>what address the program needs to start at</li>
<li>how many bytes the main section is</li>
<li>The address of the program&rsquo;s entry point</li>
</ol></li>
<li>Copy the segment marked LOAD into memory at the right address</li>
<li>Jump to the start of the program!</li>
</ol>

<p>This is what the code I have so far looks like. You can see that it&rsquo;s
mostly an ELF header definition, and then to read it I just cast the
pointer to the array I&rsquo;m trying to read.</p>

<p>This is typical of a lot of Rust code I&rsquo;m writing &ndash; I need to write a
lot of <code>unsafe</code> code.</p>

<pre><code>pub fn read_header&lt;'a&gt;(file: &amp;'a [u8]) -&gt; &amp;'a ELFHeader {
    unsafe {
        let x : *ELFHeader = to_ptr(file) as *ELFHeader;
        return &amp;*x;
    }
}

#[packed]
struct ELFHeader {
    e_ident: ELFIdent,
    e_type: u16,
    e_machine: u16,
    e_version: u32,
    e_entry: u32,
    e_phoff: u32,
    e_shoff: u32,
    e_flags: u32,
    e_ehsize: u16,
    e_phentsize: u16,
    e_phnum: u16,
    e_shentsize: u16,
    e_shnum: u16,
    e_shstrndx: u16
}
</code></pre>

<p>and the final <code>exec</code> function will look a bit like this:</p>

<pre><code>unsafe fn jmp(addr: u32) {
    asm!(&quot;jmp *($0)&quot;
         :
         : &quot;r&quot; (addr));
}

// Executes a file starting at `addr`
pub unsafe fn exec(addr: uint) {
    let bytes: &amp;[u8] = transmute(Slice {data: (addr as *u8), len: 100});
    let header = elf::read_header(bytes);
    assert(header.e_ident.ei_mag.slice(1,4) == &quot;ELF&quot;);
    // Read the program header and load the program into memory at
    // the right address
    jmp(header.e_entry);
}
</code></pre>

<p><code>jmp</code> is a great example of an unsafe Rust function &ndash; what could be
more unsafe than jumping to a possibly arbitrary address in memory?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 44: qemu &#43; gdb = so great]]></title>
    <link href="https://jvns.ca/blog/2013/12/17/day-44-gdb-is-great/"/>
    <updated>2013-12-17T00:00:00+00:00</updated>
    <id>https://jvns.ca/blog/2013/12/17/day-44-gdb-is-great/</id>
    <content type="html"><![CDATA[<p>Today I did some more debugging and cleaning up. Previously I was
setting up my IDT (interrupt descriptor table) with assembly, but I
wanted to do it with Rust, because I don&rsquo;t really know assembly and
the less of it I have in my OS, the less of a liability it is. I&rsquo;d
tried to do this before, but it wasn&rsquo;t working.</p>

<p>What turned out to be wrong:</p>

<ul>
<li>I had <code>1 &lt;&lt; 16 - 1</code> instead of <code>(1 &lt;&lt; 16) - 1</code>, so my mask wasn&rsquo;t
working properly</li>
<li>I had the wrong function name for the interrupt handler</li>
<li>That was it!</li>
</ul>

<p>This actually ended up being really easy to debug! &ldquo;Really easy&rdquo; as in
&ldquo;it took all day, but I did not feel like hiding under the table at
any point&rdquo;. I have a symbol table, and <code>idt</code> is in it, so I just
needed to do iterations on</p>

<pre><code>gdb) x/4x &amp;idt
</code></pre>

<p>and compare the contents of memory from Working Code with the
Non-Working Code.</p>

<p><code>x/</code> means &ldquo;examine&rdquo;, and <code>4x</code> means &ldquo;as hex, 4 times`. Here&rsquo;s some
<a href="https://sourceware.org/gdb/onlinedocs/gdb/Memory.html">documentation for examining memory</a>.</p>

<p>Comparing sections of memory and figuring out why they&rsquo;re wrong is
tedious, but pretty straightforward &ndash; I had a good handle on what
all my code was doing. Pretty exciting. Best friends, gdb.</p>

<p><code>gdb</code> isn&rsquo;t totally the best interface &ndash; I can certainly imagine
having better ones. But it is Very Useful. So far I know how to</p>

<ul>
<li>Find the address of a symbol in memory</li>
<li>Look at memory (as ints, as hex, as ASCII)</li>
<li>Search memory</li>
<li>Set breakpoints (and look at assembly that I don&rsquo;t understand)</li>
<li>Make core dumps to look at later</li>
</ul>

<p>These are pretty awesome superpowers already, and I&rsquo;m sure there are
tons more.</p>

<p>So now my interrupt handlers are set up in Rust! This will make it
much easier for me to implement <code>int 80</code>, and therefore move towards
being able to run programs! Excellent! Onwards!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 43: SOMETHING IS ERASING MY PROGRAM WHILE IT’S RUNNING (oh wait oops)]]></title>
    <link href="https://jvns.ca/blog/2013/12/16/day-43-hopefully-the-last-day-spent-fixing-linker-problems/"/>
    <updated>2013-12-16T00:00:00+00:00</updated>
    <id>https://jvns.ca/blog/2013/12/16/day-43-hopefully-the-last-day-spent-fixing-linker-problems/</id>
    <content type="html"><![CDATA[<p>alternate title: &ldquo;Hopefully the last day I spend all day trying to
compile my code properly&rdquo;</p>

<p>(context: I&rsquo;m working on writing an OS, and am experiencing a
mysterious recurring bug. After many days, I have found the reason!)</p>

<p>Today I went through the following:</p>

<ol>
<li>Decide to try to write some code</li>
<li>Upgrade Rust, since my version is 8 days old</li>
<li>Oh no, the new Rust breaks my oldish version of <a href="http://github.com/thestinger/rust-core">rust-core</a></li>
<li>Upgrade rust-core</li>
<li>Oh no, the new rust-core requires me to compile in a different way</li>
<li>Spend a bunch of time messing with <code>clang</code> and friends to get
everything to compile again</li>
<li>Everything compiles. Yay!</li>
<li>Try to run code</li>
<li>Encounter mystery bug again, where my array mysteriously contains
0s instead of its actual contents</li>
<li>Make sad faces</li>
<li>Go talk to <a href="http://akaptur.github.io">Allison</a>. Allison is the best.</li>
<li>Allison asks: &ldquo;What linker debugging strategies do you have?&rdquo;

<ol>
<li>Change the linker script randomly (actual thing that has worked)</li>
<li>Change variable attributes from &lsquo;private&rsquo; to &lsquo;public&rsquo; at random
(actual other thing that has worked)</li>
<li>Look at the linker map or symbol table (not helpful, so far)</li>
<li>Attach gdb to qemu and inspect the contents of memory (!!!)</li>
</ol></li>
</ol>

<p>gdb is great. It let me</p>

<ul>
<li>search my memory for &ldquo;QWERTY&rdquo; (not there! why not?)</li>
<li>look at the memory at a given address (lots of zeros! huh!)</li>
<li>Do a core dump, and compare it to the original file. Lots of zeros!
Why is half my program gone?</li>
</ul>

<p>SURPRISE MY CODE IS NOT WORKING BECAUSE SOMETHING IS ERASING IT.</p>

<p>Can we talk about this?</p>

<ol>
<li>I have code</li>
<li>I can compile my code</li>
<li>Half of my binary gets overwritten with 0s at runtime. Why. What
did I do to deserve this?</li>
<li>No wonder the order I put the binary in matters.</li>
</ol>

<p>It is a wonder that this code even runs, man. Man.</p>

<p><strong>Edit</strong>: I found why my binary has lots of 0s in it at runtime. It is
  because I was only loading 12k of it in <code>loader.asm</code>. Hopefully this
  will serve as a lesson to someone.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 42: How to run a simple ELF executable, from scratch (I don&#39;t know)]]></title>
    <link href="https://jvns.ca/blog/2013/12/13/day-42-how-to-run-an-elf-executable-i-dont-know/"/>
    <updated>2013-12-13T00:00:00+00:00</updated>
    <id>https://jvns.ca/blog/2013/12/13/day-42-how-to-run-an-elf-executable-i-dont-know/</id>
    <content type="html"><![CDATA[

<p>I want to compile a 32-bit &ldquo;Hello, world!&rdquo; statically-linked ELF
binary for Linux, and try to run it in my
<a href="http://github.com/jvns/puddle">operating system</a>. I&rsquo;m trying to
understand what I&rsquo;ll have to do. The goal is to get everything just
barely working, so that it will print the string to the screen and not
crash the whole system.</p>

<p>I asked a question about this a little while ago, and got
<a href="https://gist.github.com/jvns/7688286/">lots of helpful responses</a>.
Now I need to make it a bit more concrete, though.</p>

<p>I&rsquo;ve discovered that this &ldquo;set stuff up so that a program can run&rdquo;
business is called <strong>loading</strong>, and what I&rsquo;m doing is writing a
<strong>loader</strong>. Sweet.</p>

<p>Right now I&rsquo;m doing this before implementing paging and virtual memory
and not after, because this seems more fun than virtual memory for
now. If this is a very bad idea, I would like to know.</p>

<h2 id="things-i-ll-have-to-do">Things I&rsquo;ll have to do</h2>

<ol>
<li>Compile &ldquo;hello-c&rdquo; for a 32-bit OS, with <code>gcc -m32 -static</code></li>
<li>Parse the ELF headers (using
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">the wikipedia article</a>,
and
<a href="https://code.google.com/p/corkami/wiki/ELF101">this great picture</a>
as a reference)</li>
<li>Add an interrupt handler for <code>int 80</code> (or <code>sysenter</code>, we&rsquo;ll see!),
so that I can handle system calls.</li>
<li>Write the actual system call implementations, as few as possible.</li>
<li>Find <code>e_entry</code>, the entry point of the binary.</li>
<li>Initialize registers? How?</li>
<li>Change <em>something</em>, so that the memory addresses in the binary
aren&rsquo;t broken. Maybe? I still don&rsquo;t 100% understand this.</li>
<li>Finally: Jump to <code>_start</code>, the memory address in <code>e_entry</code>. I want
to just do <code>jmp address</code> here. Then my program will run?</li>
</ol>

<h2 id="things-i-won-t-have-to-do-yet">Things I won&rsquo;t have to do (yet)</h2>

<ol>
<li>Read the file into memory &ndash; I&rsquo;m planning to just keep the file as
a bunch of bytes in RAM to start, or possibly have a simple RAM
filesystem later.</li>
<li>Security, and making sure process can&rsquo;t trample on each others&rsquo;
address spaces.</li>
<li>Scheduling.</li>
<li>Set up a special heap for the process. I&rsquo;m just going to allocate
everyone&rsquo;s memory in the same part of physical memory for now. And
never free. Yeah.</li>
</ol>

<h2 id="questions-i-have">Questions I have</h2>

<ol>
<li>Do I need to make sure my binary is
<a href="http://www.airs.com/blog/archives/43">position independent</a>?</li>
<li>Do I need to implement virtual memory &amp; paging? (I think not)</li>
<li>Do I need to have a separate &ldquo;user space&rdquo; for the code to run in,
or will it run in kernel space? (I think it will run in kernel
space)</li>
<li>Do I need to change something in the GOT and/or PLT to make the
addresses work right? (I think yes? maybe?) Is there even a PLT in
a static executable, or is that just for dynamic linking? Eep. Hmm.</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 39: Writing malloc wrong, for fun]]></title>
    <link href="https://jvns.ca/blog/2013/12/10/day-39-i-wrote-a-malloc/"/>
    <updated>2013-12-10T00:00:00+00:00</updated>
    <id>https://jvns.ca/blog/2013/12/10/day-39-i-wrote-a-malloc/</id>
    <content type="html"><![CDATA[<p>My major achievement for today is writing the following five lines of
code:</p>

<pre><code>let a: ~u8 = ~('A' as u8);
stdio::putc(*a);
let b: ~u8 = ~('B' as u8);
stdio::putc(*a);
stdio::putc(*b);
</code></pre>

<p>and having them do the wrong thing. One would normally expect this to
print &ldquo;AAB&rdquo;. But for me, right now, until I stop goofing off, it
prints &ldquo;ABB&rdquo;. Why is that?</p>

<p>Well, it&rsquo;s because my <code>malloc</code> implementation looks like this:</p>

<pre><code>static mut base: uint = 0x200000;
pub extern &quot;C&quot; fn malloc(len: uint) -&gt; *mut u8 {
    unsafe {
        let ret: uint = base;
        return base as *mut u8;
   }
}
</code></pre>

<p>This means that every time I allocate memory, I get the same pointer
back, and so <code>a</code> and <code>b</code> will always be equal no matter what. And for
that matter any variable I create will always have the same value.
This is of course a terrible idea in real life, but it is <em>really
fun</em>.</p>

<p>Here&rsquo;s my real <code>malloc</code> function (that causes the above code to print
&ldquo;AAB&rdquo;, like it should):</p>

<pre><code>pub extern &quot;C&quot; fn malloc(len: uint) -&gt; *mut u8 {
    unsafe {
        let ret: uint = base;
        base += len + size_of::&lt;uint&gt;();

        // Align next allocation to 4-byte boundary.
        if(base % 4 != 0) {
            base += 4 - (base % 4);
        }

        *(base as *mut uint) = len;

        return (ret + size_of::&lt;uint&gt;()) as *mut u8;
    }
}

pub extern &quot;C&quot; fn free(ptr: *mut u8) {
    // meh.
}
</code></pre>

<p>The hardest part about this was not actually writing <code>malloc</code>. Writing
<code>malloc</code> is easy, as long as you never need to free memory. I also
just wrote this by copying it from a C implementation. You just need
to keep a counter and keep incrementing it.</p>

<p>The hard part was getting the type of the function right, because Rust
:). This is entirely made up for by being able to play silly memory
games.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 38: After 6 days, I have problems that I can&#39;t understand at all]]></title>
    <link href="https://jvns.ca/blog/2013/12/06/day-38-after-7-days/"/>
    <updated>2013-12-06T00:00:00+00:00</updated>
    <id>https://jvns.ca/blog/2013/12/06/day-38-after-7-days/</id>
    <content type="html"><![CDATA[<p>tl;dr: I expect <code>NUMS[2]</code> to equal <code>NUMS[keycode]</code> when <code>keycode ==
2</code>. This doesn&rsquo;t appear to be the case, and I don&rsquo;t understand how
this is possible.</p>

<p>I&rsquo;m trying to set up keycode handling in my kernel, and I&rsquo;m having a
strange problem with array indexing that I can&rsquo;t really fathom at all
(except &ldquo;something is wrong&rdquo;).</p>

<p>When I run this code, and press <code>1</code> several times, it prints <code>|2C |2C |2C |2C |2C |2C |2C |2C |2C</code>.</p>

<p>I am expecting it to print <code>|2C2|2C2|2C2|2C2|2C2|2C2|2C2|2C2|2C2|</code>.</p>

<p>Here is the code:</p>

<pre><code>// some imports removed
static NUMS: &amp;'static [u8] = bytes!(&quot;01234567890&quot;);

#[no_mangle]
pub unsafe fn _interrupt_handler_kbd() {
    let keycode: u8 = inb(0x60);
    if (keycode == 2 || keycode == 3) {
        stdio::putc(NUMS[2]); // should be '2'. It is.
        stdio::putc(65 + keycode); // should be 'C' (keycode = 2), because 'A' is 65 
        stdio::putc(NUMS[keycode]); // should be '2', BUT IT ISN'T. IT IS SOMETHING ELSE. HOW IS THIS HAPPENING. 
        stdio::putc(124); /// this is '|', just as a delimiter.
    }
    outb(0x20, 0x20); // Tell the interrupt handler that we're done.
}
</code></pre>

<p>To summarize:</p>

<ul>
<li>the <code>2</code> is printed by <code>putc(NUMS[2])</code></li>
<li>the <code>C</code> is printed by <code>putc(65 + keycode)</code>. This implies that <code>keycode == 2</code>, since 65 is &lsquo;A&rsquo;</li>
<li>the blank space is printed by <code>putc(NUMS[keycode])</code>. I would expect this to print <code>2</code>. But no.</li>
</ul>

<p>For bonus points, if I replace <code>if (keycode == 2 || keycode == 3) {</code>
with <code>if(keycode == 2) {</code>, then it prints
<code>|2C2|2C2|2C2|2C2|2C2|2C2|2C2|2C2|2C2|</code>, which is right. I think this
is because of a compiler optimization replacing <code>keycode</code> with <code>2</code>.</p>

<p>If you have <code>qemu</code> and a nightly build of <code>rust</code> installed, you can
run this code by doing</p>

<pre><code>git clone git@github.com:jvns/rustboot.git
cd rustboot
git checkout origin/compiler-nonsense
git submodule init
git submodule update
make run
</code></pre>

<p>Some hypotheses:</p>

<ul>
<li>There&rsquo;s something wrong with the Rust compiler</li>
<li>There&rsquo;s something wrong with the stack and how I&rsquo;m calling
<code>_interrupt_handler_kbd</code></li>
<li>?????????</li>
</ul>

<p>I also can&rsquo;t yet find the address of <code>_interrupt_handler_kbd</code> to look
at the assembly to debug. It&rsquo;s in the symbol table of the original
object file (<code>main.o</code>), but after linking it&rsquo;s not in <code>main.bin</code>, so I
can&rsquo;t set a breakpoint in gdb.</p>

<p>Ack.</p>

<p><strong>Edit:</strong> <a href="http://brian.mastenbrook.net/">Brian Mastenbrook</a> suggested
to link using ELF and then use objcopy to create a binary, and that
somehow magically fixed the problem
(<a href="https://github.com/jvns/rustboot/commit/2dab3a8ca693a1754b498f05472670e15343bb07">this commit</a>).
If anyone can explain why, I would be Extremely Interested.</p>
]]></content>
  </entry>
  
</feed>